<!DOCTYPE html />

<html>
<head>
	<title>connection.js</title>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
	<link href="../nocco.css" rel="stylesheet" media="all" type="text/css" />
	<script src="../prettify.js" type="text/javascript"></script>
</head>
<body onload="prettyPrint()">
	<div id="container">
		<div id="background"></div>
			<div id="jump_to">
				Jump To &hellip;
				<div id="jump_wrapper">
					<div id="jump_page">
							<a class="source" href="../xrtc/ajax.html">
								xrtc\ajax.js
							</a>
							<a class="source" href="../xrtc/authmanager.html">
								xrtc\authManager.js
							</a>
							<a class="source" href="../xrtc/class.html">
								xrtc\class.js
							</a>
							<a class="source" href="../xrtc/common.html">
								xrtc\common.js
							</a>
							<a class="source" href="../xrtc/commonerror.html">
								xrtc\commonError.js
							</a>
							<a class="source" href="../xrtc/connection.html">
								xrtc\connection.js
							</a>
							<a class="source" href="../xrtc/datachannel.html">
								xrtc\dataChannel.js
							</a>
							<a class="source" href="../xrtc/eventdispatcher.html">
								xrtc\eventDispatcher.js
							</a>
							<a class="source" href="../xrtc/handshakecontroller.html">
								xrtc\handshakeController.js
							</a>
							<a class="source" href="../xrtc/logger.html">
								xrtc\logger.js
							</a>
							<a class="source" href="../xrtc/room.html">
								xrtc\room.js
							</a>
							<a class="source" href="../xrtc/serverconnector.html">
								xrtc\serverConnector.js
							</a>
							<a class="source" href="../xrtc/stream.html">
								xrtc\stream.js
							</a>
							<a class="source" href="../xrtc/usermedia.html">
								xrtc\userMedia.js
							</a>
					</div>
				</div>
			</div>
		<table cellpadding="0" cellspacing="0">
			<thead>
				<tr>
					<th class="docs">
						<h1>connection.js</h1>
					</th>
					<th class="code"></th>
				</tr>
			</thead>
			<tbody>
					<tr id="section_1">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_1">&#182;</a>
							</div>
							<h4>Version 1.5.0</h4>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_2">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_2">&#182;</a>
							</div>
							<p><code>xRtc.Connection</code> is one of the main objects of <strong>xRtc</strong> library. This object can not be created manually.
For the creation of connection need to use <code>xRtc.Room</code> object.
The main goal of this object is handling real p2p connection.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_3">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_3">&#182;</a>
							</div>
							<p><code>goog.provide</code>, <code>goog.require</code> defined in <strong>Google Closure Library</strong>. It is used by <strong>Google Closure Compiler</strong> for the determination of the file order.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>goog.provide(&#39;xRtc.connection&#39;);

goog.require(&#39;xRtc.baseClass&#39;);
goog.require(&#39;xRtc.eventDispatcher&#39;);
goog.require(&#39;xRtc.logger&#39;);
goog.require(&#39;xRtc.common&#39;);
goog.require(&#39;xRtc.commonError&#39;);
goog.require(&#39;xRtc.stream&#39;);
goog.require(&#39;xRtc.dataChannel&#39;);

</code></pre>
						</td>
					</tr>
					<tr id="section_4">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_4">&#182;</a>
							</div>
							<p><strong>Todo:</strong> need to think of unsubscribing from all events after connection will be closed. The same for all XTC objects.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
(function (exports) {
	&#39;use strict&#39;;

	if (typeof exports.xRtc === &#39;undefined&#39;) {
		exports.xRtc = {};
	}

	var xrtc = exports.xRtc,
		internal = {},
		webrtc = xrtc.webrtc;

</code></pre>
						</td>
					</tr>
					<tr id="section_5">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_5">&#182;</a>
							</div>
							<p><code>IceCandidateFilter</code> is internal object of <code>xRtc.Connection</code>. The object contains functionality which helps to filter webrtc ice candidates in case if <code>server</code> or <code>direct</code> connection is required.
<strong>Note:</strong> Detailed information about SDP you can found here <a href="http://webrtchacks.com/sdp-anatomy/">http://webrtchacks.com/sdp-anatomy/</a></p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>	xrtc.Class(internal, &#39;IceCandidateFilter&#39;, function IceCandidateFilter(type, iceServers) {
		var connectionType = type || xrtc.Connection.connectionTypes.default,
			ipRegexp = /(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/g;

		xrtc.Class.extend(this, {
</code></pre>
						</td>
					</tr>
					<tr id="section_6">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_6">&#182;</a>
							</div>
							<p>Returns type of the current connection.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			getType: function () {
				return connectionType;
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_7">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_7">&#182;</a>
							</div>
							<p>Returns ice candidate corresponding to connection type.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			filterCandidate: function (iceCandidate) {
				var resultCandidate = null;
				if (connectionType === xrtc.Connection.connectionTypes.default) {
					resultCandidate = iceCandidate;
				}
				else if (connectionType === xrtc.Connection.connectionTypes.direct &amp;&amp;
					(iceCandidateTypeDetector.isLocal(iceCandidate) || iceCandidateTypeDetector.isStun(iceCandidate))) {
					resultCandidate = iceCandidate;
				} else if (connectionType === xrtc.Connection.connectionTypes.server) {
					if (iceCandidateTypeDetector.isTurn(iceCandidate)) {
						resultCandidate = iceCandidate;
					}
					else if (iceCandidateTypeDetector.isStun(iceCandidate)) {
</code></pre>
						</td>
					</tr>
					<tr id="section_8">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_8">&#182;</a>
							</div>
							<p>In some situations if STUN connection is possible then WebRTC won't generate TURN candidates.
As a result need to convert STUN candidates to TURN candidates.
<strong>Todo:</strong> Need to check necessity of this logic</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>						resultCandidate = stun2Turn(iceCandidate);
					}
				}

				return resultCandidate;
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_9">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_9">&#182;</a>
							</div>
							<p>Returns <code>sdp</code> which corrected accordingly current connection type.
<strong>Note:</strong> FireFox <code>offer</code> and <code>answer</code> contains all ice candidates which should be deleted if connection type is <code>server</code> (equals <code>xrtc.Connection.connectionTypes.server</code>).</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			filterSDP: function (sdp) {
				var changedSdp = sdp;
				if (connectionType === xrtc.Connection.connectionTypes.server) {
</code></pre>
						</td>
					</tr>
					<tr id="section_10">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_10">&#182;</a>
							</div>
							<p>This regex removes from <code>sdp</code> all direct p2p <code>host</code> and STUN <code>srflx</code> ice candidates from the <code>sdp</code>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>					changedSdp = sdp.replace(/a=candidate:.*((typ host)|(typ srflx)).*\r\n/g, &quot;&quot;);
				} else if (connectionType === xrtc.Connection.connectionTypes.direct) {
</code></pre>
						</td>
					</tr>
					<tr id="section_11">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_11">&#182;</a>
							</div>
							<p>This regex removes from <code>sdp</code> all TURN <code>relay</code> ice candidates from the <code>sdp</code>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>					changedSdp = sdp.replace(/a=candidate:.*typ relay.*\r\n/g, &quot;&quot;);
				}

				return changedSdp;
			}
		});

</code></pre>
						</td>
					</tr>
					<tr id="section_12">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_12">&#182;</a>
							</div>
							<p>Internal ice candidate type detector.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>		var iceCandidateTypeDetector = {
</code></pre>
						</td>
					</tr>
					<tr id="section_13">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_13">&#182;</a>
							</div>
							<p>Returns true if passed <code>iceCandidate</code> is LOCAL otherwise returns false.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			isLocal: function (iceCandidate) {
				return /typ host/.test(iceCandidate.candidate);
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_14">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_14">&#182;</a>
							</div>
							<p>Returns true if passed <code>iceCandidate</code> is STUN otherwise returns false.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			isStun: function (iceCandidate) {
				return /typ srflx/.test(iceCandidate.candidate);
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_15">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_15">&#182;</a>
							</div>
							<p>Returns true if passed <code>iceCandidate</code> is TURN otherwise returns false.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			isTurn: function (iceCandidate) {
				return /typ relay/.test(iceCandidate.candidate);
			}
		};

</code></pre>
						</td>
					</tr>
					<tr id="section_16">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_16">&#182;</a>
							</div>
							<p>Returns IP address of the TURN server from array of ice servers.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>		function getIceServersTurnIP(iceServersArray) {
			var turnIpAddress = null;
			if (iceServersArray) {
				for (var i = 0; i &lt; iceServersArray.length; i++) {
					var server = iceServersArray[i];
					if (server.url.indexOf(&#39;turn:&#39;) === 0 /*if server is TURN server*/) {
						if (server.url.indexOf(&#39;@&#39;) !== -1 /*if TURN address have old format. Old format is actual for Chrome &lt; 28 version*/) {
							turnIpAddress = server.url.split(&#39;@&#39;)[1];
						} else {
							turnIpAddress = server.url.split(&#39;turn:&#39;)[1];
						}
					}
				}
			}
			return turnIpAddress;
		}

</code></pre>
						</td>
					</tr>
					<tr id="section_17">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_17">&#182;</a>
							</div>
							<p>Converts STUN ice candidate to TURN ice candidate.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>		function stun2Turn(iceCandidate) {
			var resultTurnCandidate = null;
			var turnIpAddress = getIceServersTurnIP(iceServers);
			if (turnIpAddress) {
				resultTurnCandidate = iceCandidate;
				resultTurnCandidate.candidate = /*change IP address*/ iceCandidate.candidate.replace(ipRegexp, turnIpAddress);
				resultTurnCandidate.candidate = /*change candidate type*/ iceCandidate.candidate.replace(&#39;typ srflx&#39;, &#39;typ relay&#39;);
			}

			return resultTurnCandidate;
		}
	});

</code></pre>
						</td>
					</tr>
					<tr id="section_18">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_18">&#182;</a>
							</div>
							<p><strong>Todo:</strong> Need to optimize the constructor sugnature of Connection object.
It is internal constructor . The <code>xRtc.Room</code> object uses this constructor for creation connections objects.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>	xrtc.Class(xrtc, &#39;Connection&#39;, function Connection(connId, ud, remoteUser, hc, am, data) {
		var proxy = xrtc.Class.proxy(this),
			logger = new xrtc.Logger(this.className),
			userData = ud,
			authManager = am || new xRtc.AuthManager(),
			localStreams = [],
			remoteStreams = [],
			dataChannels = [],
			dataChannelConfigs = [],
			peerConnection = null,
			checkConnectionStateIntervalId = null,
			checkDisconnectedIceStateTimeoutId = null,
			handshakeController = hc,
			iceFilter = null,
</code></pre>
						</td>
					</tr>
					<tr id="section_19">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_19">&#182;</a>
							</div>
							<p>Variable for caching ice servers which was requested from the server side.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			iceServers = null,
</code></pre>
						</td>
					</tr>
					<tr id="section_20">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_20">&#182;</a>
							</div>
							<p>This field is used to determine whether the coonection was accepted and need to send ice candidates to remote application.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			connectionEstablished = false,
</code></pre>
						</td>
					</tr>
					<tr id="section_21">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_21">&#182;</a>
							</div>
							<p>It is tempoprary storage of ice candidates.
Ice candidates should be send to remote user after receiving <code>answer</code> strictly.
If the application will send ice candidates after <code>offer</code> sending then it can be skipped by remote application
because there is no guarantee of connection establishing and while the application/user will be thinking
about accept/decline incoming connection these ice candidates reach it and will be skipped,
because the remote peerConnection still not created.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			iceCandidates = [],
			connectionId = connId,
</code></pre>
						</td>
					</tr>
					<tr id="section_22">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_22">&#182;</a>
							</div>
							<p>Internal user data conainer. The data helps to identify the connection and differ the connection from other connections.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			connectionData = data,
			connectionIsOpened = false;

		subscribeToHandshakeControllerEvents.call(this);

		xrtc.Class.extend(this, xrtc.EventDispatcher, {
			_logger: logger,

</code></pre>
						</td>
					</tr>
					<tr id="section_23">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_23">&#182;</a>
							</div>
							<p><strong>[Public API]:</strong> It is public method of <code>connection</code> object. This method returns ID of the <code>connection</code>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			getId: function () {
				return connectionId;
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_24">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_24">&#182;</a>
							</div>
							<p><strong>[Public API]:</strong> It is public method of <code>connection</code> object. This method returns remote user of the <code>connection</code>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			getRemoteUser: function () {
				return remoteUser;
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_25">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_25">&#182;</a>
							</div>
							<p>It is internal method. It should not be used manually.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			_open: function (options) {
				connectionIsOpened = true;

				var self = this,
					offerOptions = {};

</code></pre>
						</td>
					</tr>
					<tr id="section_26">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_26">&#182;</a>
							</div>
							<p>offerOptions field initialization.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>				xrtc.Class.extend(offerOptions, xrtc.Connection.settings.offerOptions);
				if (options &amp;&amp; options.offer) {
					xrtc.Class.extend(offerOptions, options.offer);
				}

				self.trigger(xrtc.Connection.events.connectionOpening, { connection: self, user: remoteUser });

				initPeerConnection.call(self, remoteUser, function () {
					iceFilter = new internal.IceCandidateFilter(options &amp;&amp; options.connectionType || null, iceServers);

					peerConnection.createOffer(proxy(onCreateOfferSuccess), proxy(onCreateOfferError), offerOptions);

					function onCreateOfferSuccess(offer) {
</code></pre>
						</td>
					</tr>
					<tr id="section_27">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_27">&#182;</a>
							</div>
							<p><strong>Note:</strong> <code>peerConnection</code> object can be <code>null</code> in case if connection was created and closed straightway.
So after it async <code>onCreateOfferSuccess</code> will start and 'peerConnection' will be <code>null</code>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>						if (peerConnection) {
							if (webrtc.detectedBrowser === webrtc.supportedBrowsers.firefox) {
								offer.sdp = iceFilter.filterSDP(offer.sdp);
							}

							logger.debug(&#39;onCreateOfferSuccess&#39;, offer);

							peerConnection.setLocalDescription(offer);

</code></pre>
						</td>
					</tr>
					<tr id="section_28">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_28">&#182;</a>
							</div>
							<p>This magis is required for interoperability support of FF21 and Chrome.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>							if (webrtc.detectedBrowser === webrtc.supportedBrowsers.firefox &amp;&amp; webrtc.detectedBrowserVersion &lt;= 21) {
								var inline = &#39;a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:FakeFakeFakeFakeFakeFakeFakeFakeFakeFake\r\nc=IN&#39;;
								offer.sdp = offer.sdp.indexOf(&#39;a=crypto&#39;) == -1 ? offer.sdp.replace(/c=IN/g, inline) : offer.sdp;
							}

							var request = {
								offer: JSON.stringify(offer),
								connectionData: connectionData,
								connectionType: iceFilter.getType(),
								iceServers: iceServers
							};

							logger.debug(&#39;sendOffer&#39;, remoteUser.id, offer);
							handshakeController.sendOffer(remoteUser.id, connectionId, request);
							self.trigger(xrtc.Connection.events.offerSent, { connection: this, user: remoteUser, offerData: request });
						}
					}

					function onCreateOfferError(err) {
						var error = new xrtc.CommonError(&#39;startSession&#39;, &quot;Cannot create WebRTC offer&quot;, err);

						logger.error(&#39;onCreateOfferError&#39;, error);
						self.trigger(xrtc.Connection.events.createOfferError, { connection: self, error: error });
					}
				});
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_29">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_29">&#182;</a>
							</div>
							<p><strong>[Public API]:</strong> It is public method of <code>connection</code> object. This method should be used for closing the <code>connection</code>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			close: function (byeData) {
				if (handshakeController &amp;&amp; remoteUser) {
					handshakeController.sendBye(remoteUser.id, connectionId, byeData);
				}

				closePeerConnection.call(this);
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_30">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_30">&#182;</a>
							</div>
							<p><strong>[Public API]:</strong> It is public method of <code>connection</code> object. This method should be used for adding <code>xRtc.Stream</code> to the <code>connection</code>.
It is required if you want to transmit the <code>stream</code> to remote user. The <code>xRtc.Stream</code> can be obtained using <code>xRtc.getUserMedia</code> method.
One <code>connection</code> can be used for transfering some streams to remote side.
After execution this method <code>localstreamadded</code> (<code>xrtc.Connection.events.localStreamAdded</code>) event of connection object will be fired.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			addStream: function (xrtcStream) {
				if (connectionIsOpened) {
					throwExceptionOfWrongmethodCall(&#39;addStream&#39;);
				}

				localStreams.push(xrtcStream);

				var streamData = {
					connection: this,
					stream: xrtcStream,
</code></pre>
						</td>
					</tr>
					<tr id="section_31">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_31">&#182;</a>
							</div>
							<p><strong>Note:</strong> user.id equals current user name.
<strong>TODO:</strong> Need to change fake user to actual user object</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>					user: { id: userData.name, name: userData.name }
				};

				logger.debug(&#39;addLocalStream&#39;, streamData);
				this.trigger(xrtc.Connection.events.localStreamAdded, streamData);
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_32">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_32">&#182;</a>
							</div>
							<p><strong>[Public API]:</strong> It is public method of <code>connection</code> object. This method should be used for creating <code>xRtc.DataChannel</code> for the <code>connection</code>.
Names of the data channels should be unique in context of any <code>connection</code>.
<em>*Note: *</em> This method can be used only on <code>connectionCreated</code> (<code>xRtc.Room.events.connectionCreated</code>) event of the <code>xRtc.Room</code> object otherwise exception will be thrown.
It take following parameters:</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_33">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_33">&#182;</a>
							</div>
							<ul>
<li><code>name</code>. Name of the data channel. Name of the data channel should be unique among all data channels of the <code>xrtc.Connection</code> object.</li>
<li><code>config</code>. This configuration properties can be used to configure properties of the underlying channel such as binaryType , etc. It is optional parameter.</li>
</ul>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			createDataChannel: function (name, config) {
				if (connectionIsOpened) {
					throwExceptionOfWrongmethodCall(&#39;createDataChannel&#39;);
				}

</code></pre>
						</td>
					</tr>
					<tr id="section_34">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_34">&#182;</a>
							</div>
							<p>binaryType === 'blob'
binaryType = webrtc.detectedBrowser === webrtc.supportedBrowsers.chrome ? "arraybuffer" : "blob";</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
				dataChannelConfigs.push({ name: name, config: config });
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_35">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_35">&#182;</a>
							</div>
							<p><strong>[Public API]:</strong> It is public method of <code>connection</code> object. This method should be used for accessing 'specific user data' of the connection.
User/Developer can pass any data to the 'connection' in the `xRtc.Room.connect()' method. E.g. This functionality will be useful
if need to differ one connection from another because 'xRtc.Room' creates connections asynchronously.
Also it will be useful if you want to store some data which related with concrete 'connection' object.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			getData: function () {
				return connectionData;
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_36">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_36">&#182;</a>
							</div>
							<p><strong>[Public API]:</strong> It is public method of <code>connection</code> object. Returns state of the <code>connection</code>.
List of possibly connection states:</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_37">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_37">&#182;</a>
							</div>
							<ul>
<li>'ready'</li>
<li>'not-ready'</li>
<li>'connecting'</li>
<li>'disconnecting'</li>
<li>'connected'</li>
</ul>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_38">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_38">&#182;</a>
							</div>
							<p><strong>Todo:</strong> Need to revise all states.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			getState: function () {
				return getSignalingState.call(this);
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_39">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_39">&#182;</a>
							</div>
							<p><strong>[Public API]:</strong> It is public method of <code>connection</code> object. Returns <code>xRtc.Stream[]</code> object where each stream is <code>stream</code> which was added by <code>addStream</code> public method. For the most cases this <code>array</code> will be contain only one stream.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			getLocalStreams: function () {
</code></pre>
						</td>
					</tr>
					<tr id="section_40">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_40">&#182;</a>
							</div>
							<p>Return the copy of internal array.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>				return localStreams.map(function (stream) {
					return stream;
				});
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_41">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_41">&#182;</a>
							</div>
							<p><strong>[Public API]:</strong> It is public method of <code>connection</code> object. Returns <code>xRtc.Stream[]</code> object where each stream is <code>stream</code> which tranferred from the remote side.
<strong>Note:</strong> Each remote <code>xRtc.Stream</code> creates asynchronously on <code>remotestreamadded</code> (xrtc.Room.events.remoteStreamAdded) event and will be accessible in this array after mentioned event only.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			getRemoteStreams: function () {
</code></pre>
						</td>
					</tr>
					<tr id="section_42">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_42">&#182;</a>
							</div>
							<p>Return the copy of internal array.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>				return remoteStreams.map(function (stream) {
					return stream;
				});
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_43">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_43">&#182;</a>
							</div>
							<p><strong>[Public API]:</strong> It is public method of <code>connection</code> object. Returns <code>xRtc.DataChannel[]</code> object where each channel is <code>channel</code>which was created using <code>createDataChannel</code> public method.
<strong>Note:</strong> Each <code>xRtc.DataChannel</code> creates asynchronously on <code>datachannelcreated</code> (<code>xrtc.Room.events.dataChannelCreated</code>) event and will be accessible in this array after mentioned event only.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			getDataChannels: function () {
</code></pre>
						</td>
					</tr>
					<tr id="section_44">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_44">&#182;</a>
							</div>
							<p>Return the copy of internal array.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>				return dataChannels.map(function (channel) {
					return channel;
				});
			}
		});

</code></pre>
						</td>
					</tr>
					<tr id="section_45">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_45">&#182;</a>
							</div>
							<p>Internal helper method which throws appropriate exception in case when someone try to call <code>addStream</code> or <code>createDataChannel</code> methods at inappropriate time.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>		function throwExceptionOfWrongmethodCall(methodName) {
			var error = new xrtc.CommonError(methodName, &quot;The method can be called on &#39;&quot; +
				xrtc.Room.events.connectionCreated +
				&quot;&#39; event of the xRtc.Room. Use xRtc.Room.events.connectionCreated for access the event name.&quot;);
			logger.error(methodName, error);
		}

</code></pre>
						</td>
					</tr>
					<tr id="section_46">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_46">&#182;</a>
							</div>
							<p>Internal method which helps to subscribe to all events of <code>handshakeController</code> object where <code>handshakeController</code> is internal object and bridge between <code>xRtc.Connection</code> and <code>xRtc.Room</code>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>		function subscribeToHandshakeControllerEvents() {
			var hcEvents = xrtc.HandshakeController.events;
			handshakeController
				.on(hcEvents.receiveIce, proxy(onReceiveIce))
				.on(hcEvents.receiveOffer, proxy(onReceiveOffer))
				.on(hcEvents.receiveAnswer, proxy(onReceiveAnswer))
				.on(hcEvents.receiveBye, proxy(onReceiveBye));
		}

</code></pre>
						</td>
					</tr>
					<tr id="section_47">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_47">&#182;</a>
							</div>
							<p>Internal method which used for initialization of internal <code>peerConnection</code>. During execution of this method following async request will be performed:</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_48">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_48">&#182;</a>
							</div>
							<ul>
<li>Async ajax request to sever side for the <code>Token</code>.</li>
<li>Async ajax request to the sever side for the ice severs collection.</li>
</ul>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>		function initPeerConnection(user, callback) {
			remoteUser = user;

			if (!peerConnection) {
				getIceServers.call(this, proxy(onIceServersGot));
			} else {
				callCallback();
			}

</code></pre>
						</td>
					</tr>
					<tr id="section_49">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_49">&#182;</a>
							</div>
							<p><strong>Todo:</strong> Need to think of this approach and refactor it.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			function callCallback() {
				if (typeof callback === &quot;function&quot;) {
					try {
						callback();
					} catch (e) {
</code></pre>
						</td>
					</tr>
					<tr id="section_50">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_50">&#182;</a>
							</div>
							<p><strong>Todo:</strong> Check or not check?</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>					}
				}
			}

</code></pre>
						</td>
					</tr>
					<tr id="section_51">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_51">&#182;</a>
							</div>
							<p>Internal helper method which used for creation browser compatible ice servers. ice server format depens on browser and browser version.
<em>Chrome 24-27</em> uses follwing format (example):</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_52">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_52">&#182;</a>
							</div>
							<p><code>[{"url":"stun:stun.l.google.com:19302"}, {url:"turn: userName@domain.com:3478",credential:"password"}]</code></p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_53">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_53">&#182;</a>
							</div>
							<p><em>FireFox 23+</em> (in context of TURN server) and <em>Chrome 28+</em> uses following format (example):</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_54">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_54">&#182;</a>
							</div>
							<p><code>[{"url":"stun:stun.l.google.com:19302"}, {"username":"user name","url":"turn:turn.domain.com","credential":"user password"}]</code></p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			function createBrowserCompatibleIceServers(iceServersArray) {
				var browserCompatibleIceServers = [];
</code></pre>
						</td>
					</tr>
					<tr id="section_55">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_55">&#182;</a>
							</div>
							<p><strong>Note:</strong> The code regarding creation ice servers in appropriate format was copied from <a href="https://apprtc.appspot.com/js/adapter.js">https://apprtc.appspot.com/js/adapter.js</a> (official demo of the Google).</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_56">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_56">&#182;</a>
							</div>
							<p><strong>Note:</strong> <em>FF</em> &lt; 23 (maybe &lt; 24, need to check it) can't resolve IP by URL. As a result IP addresses should be used for ice servers. <em>FF</em> 24 doesn't have this problem. Checked.
Creates iceServer from the url for <em>FF</em>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>				var createFireFoxTurnServer = function (url, username, password) {
					var iceServer = null;
					var url_parts = url.split(&#39;:&#39;);
					if (url_parts[0].indexOf(&#39;stun&#39;) === 0) {
</code></pre>
						</td>
					</tr>
					<tr id="section_57">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_57">&#182;</a>
							</div>
							<p>Create iceServer with stun url.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>						iceServer = { &#39;url&#39;: removeRedundantSymbolFromTheEnd(url, &quot;/&quot;) };
					} else if (url_parts[0].indexOf(&#39;turn&#39;) === 0 &amp;&amp;
							   (url.indexOf(&#39;transport=udp&#39;) !== -1 ||
								url.indexOf(&#39;?transport&#39;) === -1)) {
</code></pre>
						</td>
					</tr>
					<tr id="section_58">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_58">&#182;</a>
							</div>
							<p>Create iceServer with turn url.
Ignore the transport parameter from TURN url.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>						var turn_url_parts = url.split(&quot;?&quot;);
						iceServer = {
							&#39;url&#39;: removeRedundantSymbolFromTheEnd(turn_url_parts[0], &quot;/&quot;),
							&#39;credential&#39;: password,
							&#39;username&#39;: username
						};
					}
					return iceServer;
				};

</code></pre>
						</td>
					</tr>
					<tr id="section_59">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_59">&#182;</a>
							</div>
							<p>Creates iceServer from the url for Chrome.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>				var createCromeTurnServer = function (url, username, password) {
					var iceServer = null;
					var url_parts = url.split(&#39;:&#39;);
					if (url_parts[0].indexOf(&#39;stun&#39;) === 0) {
</code></pre>
						</td>
					</tr>
					<tr id="section_60">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_60">&#182;</a>
							</div>
							<p>Create iceServer with stun url.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>						iceServer = { &#39;url&#39;: removeRedundantSymbolFromTheEnd(url, &quot;/&quot;) };
					} else if (url_parts[0].indexOf(&#39;turn&#39;) === 0) {
						if (webrtc.detectedBrowserVersion &lt; 28) {
</code></pre>
						</td>
					</tr>
					<tr id="section_61">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_61">&#182;</a>
							</div>
							<p>For <em>pre-M28 Chrome</em> versions use old TURN format.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>							var url_turn_parts = url.split(&quot;turn:&quot;);
							iceServer = {
								&#39;url&#39;: &#39;turn:&#39; + username + &#39;@&#39; + url_turn_parts[1],
								&#39;credential&#39;: password
							};
						} else {
</code></pre>
						</td>
					</tr>
					<tr id="section_62">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_62">&#182;</a>
							</div>
							<p>For <em>Chrome M28</em> &amp; above use new TURN format.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>							iceServer = {
								&#39;url&#39;: removeRedundantSymbolFromTheEnd(url, &quot;/&quot;),
								&#39;credential&#39;: password,
								&#39;username&#39;: username
							};
						}
					}
					return iceServer;
				};

				function removeRedundantSymbolFromTheEnd(str, symbol) {
					var result = str;
					if (str[str.length - 1] === symbol) {
						result = str.substring(0, str.length - 1);
					}

					return result;
				}

				var createBrowserCompatibleServer = function (iceServerData) {
					var resultIceServer;
					if (webrtc.detectedBrowser == webrtc.supportedBrowsers.chrome) {
						resultIceServer = createCromeTurnServer(iceServerData.url, iceServerData.username, iceServerData.credential);
					} else {
						resultIceServer = createFireFoxTurnServer(iceServerData.url, iceServerData.username, iceServerData.credential);
					}

					return resultIceServer;
				};

				for (var i = 0, l = iceServersArray.length; i &lt; l; i++) {
					var browserCompatibleServer = createBrowserCompatibleServer(iceServersArray[i]);
					if (browserCompatibleServer) {
						browserCompatibleIceServers.push(browserCompatibleServer);
					}
				}

				return browserCompatibleIceServers;
			}

			function onIceServersGot(iceServersArray) {
				var self = this;

				var browserCompatibleIceServers = createBrowserCompatibleIceServers(iceServersArray);

				peerConnection = new webrtc.RTCPeerConnection(
					browserCompatibleIceServers &amp;&amp; browserCompatibleIceServers.length &gt; 0 ? { iceServers: browserCompatibleIceServers } : null,
					xrtc.Connection.settings.peerConnectionOptions);
				logger.info(&#39;initPeerConnection&#39;, &#39;PeerConnection created.&#39;);

</code></pre>
						</td>
					</tr>
					<tr id="section_63">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_63">&#182;</a>
							</div>
							<p><strong>Note:</strong> <em>Firefox (FF 24 at least)</em> does not currently generate 'trickle candidates'. This means that it will include its
candidate addresses as 'c' lines in the <code>offer</code>/<code>answer</code>, and the onicecandidate callback will never be called.
The downside to this approach is that Firefox must wait for all of its candidates to be gathered before creating its <code>offer</code>/<code>answer</code>
(a process which can involve contacting STUN and TURN servers and waiting for either the responses or for the requests timeout).
<a href="http://stackoverflow.com/questions/15484729/why-doesnt-onicecandidate-work">http://stackoverflow.com/questions/15484729/why-doesnt-onicecandidate-work</a>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>				peerConnection.onicecandidate = proxy(onIceCandidate);

</code></pre>
						</td>
					</tr>
					<tr id="section_64">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_64">&#182;</a>
							</div>
							<p>peerConnection.onnegotiationneeded = function(evt) {};</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
				peerConnection.onstatechange = // M25-M26
</code></pre>
						</td>
					</tr>
					<tr id="section_65">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_65">&#182;</a>
							</div>
							<p><em>FF</em> 20.0.1 (<em>FF</em> 21+ works fine): during assigning <code>peerConnection.onsignalingstatechange</code> field <em>FF</em> throw following error:
NS<em>ERROR</em>XPC<em>CANT</em>MODIFY<em>PROP</em>ON_WN: Cannot modify properties of a WrappedNative</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>					peerConnection.onsignalingstatechange = // M27+, FF24+
					proxy(onConnectionStateChange);

</code></pre>
						</td>
					</tr>
					<tr id="section_66">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_66">&#182;</a>
							</div>
							<p>In <em>FireFox</em> &lt; 24 onstatechange or alternative event does not fire properly.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>				if (webrtc.detectedBrowser === webrtc.supportedBrowsers.firefox &amp;&amp; webrtc.detectedBrowserVersion &lt; 24) {
					var connectionState = this.getState();
					checkConnectionStateIntervalId = exports.setInterval(function () {
						var currentConnectionState = self.getState();
						if (currentConnectionState != connectionState) {
							logger.debug(&#39;setInterval -&gt; xrtc.Connection.events.stateChanged&#39;, currentConnectionState);
							connectionState = currentConnectionState;
							self.trigger(xrtc.Connection.events.stateChanged, { connection: self, state: connectionState });
						}
					}, 500);
				}

</code></pre>
						</td>
					</tr>
					<tr id="section_67">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_67">&#182;</a>
							</div>
							<p><strong>Todo:</strong> Need to think about the necessity of this handlers.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>				peerConnection.onicechange = // M25-M26
</code></pre>
						</td>
					</tr>
					<tr id="section_68">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_68">&#182;</a>
							</div>
							<p><em>FF 20.0.1</em> (FF 21+ works fine): during assigning peerConnection.oniceconnectionstatechange field <em>FF</em> throw following error: NS<em>ERROR</em>XPC<em>CANT</em>MODIFY<em>PROP</em>ON_WN: Cannot modify properties of a WrappedNative</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>					peerConnection.oniceconnectionstatechange = // M27+, FF24+
					proxy(onIceStateChange);

				peerConnection.ondatachannel = function (channelData) {
					var newDataChannel = new xrtc.DataChannel(channelData.channel, self);
					dataChannels.push(newDataChannel);
					self.trigger(xrtc.Connection.events.dataChannelCreated, { connection: self, channel: newDataChannel });
				};

</code></pre>
						</td>
					</tr>
					<tr id="section_69">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_69">&#182;</a>
							</div>
							<p><em>FF 19-20.0.1</em> (maybe earlier, <em>FF21</em> works fine): fire this event twice, for video stream and for audio stream despite the fact that one stream was added by remote side.
It is called any time a MediaStream is added by the remote peer. This will be fired only as a result of <code>setRemoteDescription</code>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>				peerConnection.onaddstream = proxy(onAddStream);

</code></pre>
						</td>
					</tr>
					<tr id="section_70">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_70">&#182;</a>
							</div>
							<p>For <em>FF</em> only (Tested for <em>FF24</em>. Magic, sometimes works and sometimes not.)</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>				peerConnection.onclosedconnection = function (closeData/*temporary ignores*/) {
					logger.debug(&#39;peerConnection.onclosedconnection&#39;, closeData);
					closePeerConnection.call(self);
				};

</code></pre>
						</td>
					</tr>
					<tr id="section_71">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_71">&#182;</a>
							</div>
							<p><strong>Todo:</strong> Need to fire close connection event for <em>Chrome M26</em>. The logic should be based on <code>peerConnection.iceConnectionState</code> field and <code>window.setInterval</code>.
<strong>Todo:</strong> Need to fire close connection event for <em>Chrome M25</em>. The logic should be based on <code>peerConnection.iceState</code> field and <code>window.setInterval</code>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_72">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_72">&#182;</a>
							</div>
							<p>peerConnection.iceGatheringState
W3C Editor's Draft 30 August 2013:
enum RTCIceGatheringState {
    "new",
    "gathering",
    "complete"
};</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
				function onIceCandidate(evt) {
					if (!!evt.candidate) {
						logger.debug(&#39;peerConnection.onIceCandidate&#39;, evt.candidate);
</code></pre>
						</td>
					</tr>
					<tr id="section_73">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_73">&#182;</a>
							</div>
							<p>In the original <code>RTCIceCandidate</code> class <code>candidate</code> property is immutable.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>						var ice = JSON.parse(JSON.stringify(evt.candidate));

						var filteredIce = iceFilter.filterCandidate(ice);
						if (filteredIce !== null) {
							handleIceCandidate.call(this, filteredIce);
						}
					}
				}

				function onConnectionStateChange(evt) {
					logger.debug(&#39;onConnectionStateChange&#39;, evt);
					this.trigger(xrtc.Connection.events.stateChanged, { connection: this, state: this.getState() });
				}

				function onIceStateChange(evt) {
					var state = getIceState.call(self);

					logger.debug(&quot;onIceStateChange&quot;, new Date().getTime(), state);
					if (checkDisconnectedIceStateTimeoutId) {

						logger.debug(&quot;onIceStateChange&quot;, new Date().getTime(),
							&quot;checkDisconnectedIceStateTimeout are clearing. ID = &#39;&quot; + checkDisconnectedIceStateTimeoutId + &quot;&#39;&quot;);

						exports.clearTimeout(checkDisconnectedIceStateTimeoutId);
						checkDisconnectedIceStateTimeoutId = null;

						logger.debug(&quot;onIceStateChange&quot;, new Date().getTime(),
							&quot;checkDisconnectedIceStateTimeout was cleared. ID = &#39;&quot; + checkDisconnectedIceStateTimeoutId + &quot;&#39;&quot;);
					}

					if (state === &#39;connected&#39;) {
</code></pre>
						</td>
					</tr>
					<tr id="section_74">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_74">&#182;</a>
							</div>
							<p><strong>Todo:</strong> Need to think about name of this event.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>						self.trigger(xrtc.Connection.events.connectionEstablished, { connection: self, user: remoteUser });
					} else if (state === &#39;disconnected&#39;) {
						var closeDisconnectedConnectionTimeout = 10000;

						logger.debug(&quot;onIceStateChange&quot;, new Date().getTime(),
							&quot;checkDisconnectedIceStateTimeout(&quot; + closeDisconnectedConnectionTimeout / 1000 + &quot;sec.) was started.&quot;);

						checkDisconnectedIceStateTimeoutId = exports.setTimeout(function () {

							logger.debug(&quot;onIceStateChange&quot;, new Date().getTime(),
								&quot;ice state equals &#39;disconnected&#39; so closePeerConnection was called. Timeout is &quot; +
									closeDisconnectedConnectionTimeout / 1000 + &quot;sec and it is expired.&quot;);

</code></pre>
						</td>
					</tr>
					<tr id="section_75">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_75">&#182;</a>
							</div>
							<p><strong>Todo:</strong> The event should't be repeated for <em>FF 24+</em>, because <em>FF 18+</em> has peerConnection.onclosedconnection and <em>FF 24+</em> has peerConnection.oniceconnectionstatechange.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>							closePeerConnection.call(self);
							exports.clearInterval(checkDisconnectedIceStateTimeoutId);
							checkDisconnectedIceStateTimeoutId = null;
						}, closeDisconnectedConnectionTimeout);

						logger.debug(&quot;onIceStateChange&quot;, new Date().getTime(),
							&quot;checkDisconnectedIceStateTimeout ID =&#39;&quot; + checkDisconnectedIceStateTimeoutId + &quot;&#39;&quot;);
					}
				}

				function onAddStream(evt) {
					addRemoteStream.call(this, evt.stream);
				}

</code></pre>
						</td>
					</tr>
					<tr id="section_76">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_76">&#182;</a>
							</div>
							<p>Add streams to native webrtc peerConnection which were added before.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>				for (var i = 0, len = localStreams.length; i &lt; len; i++) {
					peerConnection.addStream(localStreams[i].getStream());
				}

</code></pre>
						</td>
					</tr>
					<tr id="section_77">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_77">&#182;</a>
							</div>
							<p>Create data channnels which were created(registered for creation) before.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>				for (var i = 0, len = dataChannelConfigs.length; i &lt; len; i++) {
					createDataChannel.call(this, dataChannelConfigs[i]);
				}

				callCallback();
			}
		}

</code></pre>
						</td>
					</tr>
					<tr id="section_78">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_78">&#182;</a>
							</div>
							<p>Internal helper method which creates new instance of DataChannel by channel source <code>{name, config}</code>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>		function createDataChannel(dataChannelConfig) {
			var self = this;
			try {
</code></pre>
						</td>
					</tr>
					<tr id="section_79">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_79">&#182;</a>
							</div>
							<p><em>FF 19-21(and 18 maybe)</em>: Data channels should be created after connection establishment.
Connection should be established usually with audio and/or video.  For the time being,
always at least include a 'fake' audio stream - this will be fixed soon.
After connection establishment need to call <code>pc.connectDataConnection(5001, 5000);</code> on th each side.
For the two sides need to use inverted copies of the two numbers (e.g. <code>5000</code>, <code>5001</code> on one side, <code>5001</code>, <code>5000</code> on the other).
connectDataConnection is a temporary function that will soon disappear.
For more information see <a href="https://hacks.mozilla.org/2012/11/progress-update-on-webrtc-for-firefox-on-desktop/">https://hacks.mozilla.org/2012/11/progress-update-on-webrtc-for-firefox-on-desktop/</a></p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_80">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_80">&#182;</a>
							</div>
							<p>As a result current library approach of data channels creation works only for <em>FF 22+</em>.
for earlier versions exception will be thrown: Component returned failure code:
0x80004005 (NS<em>ERROR</em>FAILURE) [IPeerConnection.createDataChannel]" nsresult: "0x80004005 (NS<em>ERROR</em>FAILURE)"</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_81">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_81">&#182;</a>
							</div>
							<p>Reliable channel is chanel which works using RTCP protocol, unreliable channels uses UDP protocol.
RTCP data channels supported only in <em>FF</em> and <em>Chrome 31+</em>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_82">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_82">&#182;</a>
							</div>
							<p>Data channels works in following cases:</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_83">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_83">&#182;</a>
							</div>
							<ul>
<li>FireFox 22+ to FireFox 22+;</li>
<li>Chrome 31+ to Chrome 31+ (Note: Chrome 32+ data channels can work only with Chrome 32+);</li>
<li>FireFox 26+ to Chrome 32+;</li>
<li>Chrome 32+ to FireFox 26+.</li>
</ul>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
				var dc;
				if (xrtc.webrtc.supports.sctp) {
					dc = peerConnection.createDataChannel(dataChannelConfig.name, { reliable: true });
</code></pre>
						</td>
					</tr>
					<tr id="section_84">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_84">&#182;</a>
							</div>
							<p>Default value of <code>binaryType</code> for Chrome is <code>'arraybuffer'</code>, for FireFox is <code>'blob'</code> and <code>'blob'</code> doesn't supported by Chrome at now (Chrome 32).</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>					dc.binaryType = &#39;arraybuffer&#39;;
				} else {
					dc = peerConnection.createDataChannel(dataChannelConfig.name, { reliable: false });
				}

				var newDataChannel = new xrtc.DataChannel(dc, self);
				dataChannels.push(newDataChannel);
</code></pre>
						</td>
					</tr>
					<tr id="section_85">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_85">&#182;</a>
							</div>
							<p><strong>Note:</strong> <code>peerConnection.ondatachannel</code> fires only for the remote side. So this event is required.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>				self.trigger(xrtc.Connection.events.dataChannelCreated, { connection: self, channel: newDataChannel });
			} catch (ex) {
				var error = new xrtc.CommonError(&#39;createDataChannel&#39;, &quot;Can&#39;t create DataChannel.&quot;, ex);
				logger.error(&#39;createDataChannel&#39;, error);
				self.trigger(xrtc.Connection.events.dataChannelCreationError, { connection: self, channelConfig: dataChannelConfig, error: error });
			}
		}

		function handleIceCandidate(ice) {
			iceCandidates.push(ice);

			if (connectionEstablished) {
				sendIceCandidates.call(this);
			}
		}

		function allowIceSending() {
			connectionEstablished = true;

</code></pre>
						</td>
					</tr>
					<tr id="section_86">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_86">&#182;</a>
							</div>
							<p>Send already generated ice candidates.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			sendIceCandidates.call(this);
		}

		function sendIceCandidates() {
			logger.debug(&#39;sendIceCandidates&#39;, &#39;Sending &quot;&#39; + iceCandidates.length + &#39;&quot; ice candidates.&#39;);
			for (var i = 0, l = iceCandidates.length; i &lt; l; i++) {
				var iceCandidate = iceCandidates[i];

				handshakeController.sendIce(remoteUser.id, connectionId, JSON.stringify(iceCandidate));
				this.trigger(xrtc.Connection.events.iceSent, { connection: this, iceCandidate: iceCandidate });
			}

			iceCandidates = [];
		}

		function addRemoteStream(stream) {
			var newXrtcStream = new xrtc.Stream(stream);
			remoteStreams.push(newXrtcStream);

			var streamData = {
				user: remoteUser,
				connection: this,
				stream: newXrtcStream
			};

			logger.debug(&#39;addRemoteStream&#39;, streamData);

			this.trigger(xrtc.Connection.events.remoteStreamAdded, streamData);
		}

		function getIceServers(callback) {
			if (typeof callback === &quot;function&quot;) {
				if (iceServers) {
					callback(iceServers);
				} else {
					authManager.getIceServers(userData, function (servers) {
						iceServers = servers;
						callback(iceServers);
					});
				}
			}
		}

		function onReceiveIce(iceData) {
			logger.debug(&#39;Ice candidate was received.&#39;, iceData);
			var iceCandidate = new webrtc.RTCIceCandidate(JSON.parse(iceData.iceCandidate));
			peerConnection.addIceCandidate(iceCandidate);

			this.trigger(xrtc.Connection.events.iceAdded, { connection: this, iceCandidate: iceCandidate });
		}

		function onReceiveOffer(offerData) {
			this.trigger(xrtc.Connection.events.offerReceived, { connection: this, user: remoteUser, offerData: offerData });
			this.trigger(xrtc.Connection.events.connectionOpening, { connection: this, user: remoteUser });

			logger.debug(&#39;Offer was received.&#39;, offerData);

			iceServers = offerData.iceServers;

			initPeerConnection.call(this, remoteUser, proxy(onPeerConnectionInit));

			function onPeerConnectionInit() {
				logger.debug(&#39;receiveOffer&#39;, offerData);
				iceFilter = new internal.IceCandidateFilter(offerData.connectionType, iceServers);

				var sdp = JSON.parse(offerData.offer);

				var remoteSessionDescription = new webrtc.RTCSessionDescription(sdp);
				peerConnection.setRemoteDescription(remoteSessionDescription);

				peerConnection.createAnswer(proxy(onCreateAnswerSuccess), proxy(onCreateAnswerError), xrtc.Connection.settings.answerOptions);

				function onCreateAnswerSuccess(answer) {
					if (webrtc.detectedBrowser === webrtc.supportedBrowsers.firefox) {
						answer.sdp = iceFilter.filterSDP(answer.sdp);
					}

					peerConnection.setLocalDescription(answer);

					var request = {
						answer: JSON.stringify(answer),
						acceptData: offerData.acceptData
					};

					logger.debug(&#39;sendAnswer&#39;, offerData, answer);
					handshakeController.sendAnswer(remoteUser.id, connectionId, request);

					this.trigger(xrtc.Connection.events.answerSent, { connection: this, user: remoteUser, answerData: request });
					this.trigger(xrtc.Connection.events.connectionEstablishing, { connection: this, user: remoteUser });

					allowIceSending.call(this);
				}

				function onCreateAnswerError(err) {
					var error = new xrtc.CommonError(&#39;sendAnswer&#39;, &quot;Cannot create WebRTC answer&quot;, err);

					logger.error(&#39;sendAnswer&#39;, error);
					this.trigger(xrtc.Connection.events.createAnswerError, { connection: this, error: error });
				}
			}
		}

		function onReceiveAnswer(answerData) {
			logger.debug(&#39;Answer was received.&#39;, answerData);

			allowIceSending.call(this);

			var sdp = JSON.parse(answerData.answer);
			var sessionDescription = new webrtc.RTCSessionDescription(sdp);
			peerConnection.setRemoteDescription(sessionDescription);
			this.trigger(xrtc.Connection.events.answerReceived, { connection: this, user: remoteUser, answerData: { answer: sessionDescription } });
			this.trigger(xrtc.Connection.events.connectionEstablishing, { connection: this, user: remoteUser });
		}

		function onReceiveBye() {
			closePeerConnection.call(this);
		}

		function closePeerConnection() {
			var self = this;

			if (webrtc.detectedBrowser === webrtc.supportedBrowsers.firefox &amp;&amp; checkConnectionStateIntervalId) {
				exports.clearInterval(checkConnectionStateIntervalId);
				checkConnectionStateIntervalId = null;
			}

			if (peerConnection) {
				peerConnection.onicecandidate = null;
				peerConnection.close();
				peerConnection = null;
				iceCandidates = [];
				iceServers = null;
				connectionEstablished = false;
				connectionIsOpened = false;

				var closeConnectionData = {
					user: remoteUser,
					connection: self
				};

				remoteUser = null;

				this.trigger(xrtc.Connection.events.connectionClosed, closeConnectionData);
			}
		}

		function getIceState() {
			/* W3C Editor&#39;s Draft 30 August 2013:
			enum RTCIceConnectionState {
				&quot;new&quot;,
				&quot;checking&quot;,
				&quot;connected&quot;,
				&quot;completed&quot;,
				&quot;failed&quot;,
				&quot;disconnected&quot;,
				&quot;closed&quot;
			};
			*/

			var state = peerConnection
							&amp;&amp; (peerConnection.iceConnectionState // M26+
							|| peerConnection.iceState) // M25
						|| &#39;notinitialized&#39;;

			return state;
		}

</code></pre>
						</td>
					</tr>
					<tr id="section_87">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_87">&#182;</a>
							</div>
							<p><strong>Todo:</strong> Need to think about available states.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>		function getSignalingState() {
			/* W3C Editor&#39;s Draft 30 August 2013:
			enum RTCSignalingState {
				&quot;stable&quot;,
				&quot;have-local-offer&quot;,
				&quot;have-remote-offer&quot;,
				&quot;have-local-pranswer&quot;,
				&quot;have-remote-pranswer&quot;,
				&quot;closed&quot;
			};
			*/

</code></pre>
						</td>
					</tr>
					<tr id="section_88">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_88">&#182;</a>
							</div>
							<p><strong>Warning:</strong> It can change from version to version.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			var isLocalStreamAdded = localStreams.length &gt; 0,
				states = {
</code></pre>
						</td>
					</tr>
					<tr id="section_89">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_89">&#182;</a>
							</div>
							<p><strong>Todo:</strong> Why not-ready if local stream is not added? What about situation when only text chat will be used?</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>					&#39;notinitialized&#39;: isLocalStreamAdded ? &#39;ready&#39; : &#39;not-ready&#39;,

</code></pre>
						</td>
					</tr>
					<tr id="section_90">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_90">&#182;</a>
							</div>
							<p><em>Chrome M25</em>.
<strong>Todo:</strong> Why not-ready if local stream is not added? What about situation when only text chat will be used?</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>					&#39;new&#39;: isLocalStreamAdded ? &#39;ready&#39; : &#39;not-ready&#39;,
					&#39;opening&#39;: &#39;connecting&#39;,
					&#39;active&#39;: &#39;connected&#39;,
					&#39;closing&#39;: &#39;disconnecting&#39;,
</code></pre>
						</td>
					</tr>
					<tr id="section_91">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_91">&#182;</a>
							</div>
							<p><strong>Todo:</strong> Why not-ready if local stream is not added? What about situation when only text chat will be used?</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>					&#39;closed&#39;: isLocalStreamAdded ? &#39;ready&#39; : &#39;not-ready&#39;,

</code></pre>
						</td>
					</tr>
					<tr id="section_92">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_92">&#182;</a>
							</div>
							<p><em>Chrome M26+</em>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>					&#39;stable&#39;: &#39;connected&#39;,
					&#39;have-local-offer&#39;: &#39;ready&#39;,
					&#39;have-remote-offer&#39;: &#39;connecting&#39;
				},
				state = peerConnection
						&amp;&amp; (peerConnection.signalingState // M26+
						|| peerConnection.readyState) // M25-M26
					|| &#39;notinitialized&#39;;

			return states[state];
		}
	});

	xrtc.Connection.extend({
</code></pre>
						</td>
					</tr>
					<tr id="section_93">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_93">&#182;</a>
							</div>
							<p><strong>Note:</strong> Full list of events for the <code>xRtc.Connection</code> object.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>		events: {
</code></pre>
						</td>
					</tr>
					<tr id="section_94">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_94">&#182;</a>
							</div>
							<p><strong>Main events</strong></p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			connectionOpening: &#39;connectionopening&#39;,
			connectionEstablishing: &#39;connectionestablishing&#39;,
			connectionEstablished: &#39;connectionestablished&#39;,
			connectionClosed: &#39;connectionclosed&#39;,

			localStreamAdded: &#39;localstreamadded&#39;,
			remoteStreamAdded: &#39;remotestreamadded&#39;,

			dataChannelCreated: &#39;datachannelcreated&#39;,
			dataChannelCreationError: &#39;datachannelcreationerror&#39;,

			stateChanged: &#39;statechanged&#39;,

</code></pre>
						</td>
					</tr>
					<tr id="section_95">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_95">&#182;</a>
							</div>
							<p><strong>Low level events</strong></p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			createOfferError: &#39;createoffererror&#39;,
			offerSent: &#39;offersent&#39;,
			offerReceived: &#39;offerreceived&#39;,

			createAnswerError: &#39;createanswererror&#39;,
			answerSent: &#39;answersent&#39;,
			answerReceived: &#39;answerreceived&#39;,

			iceSent: &#39;icesent&#39;,
			iceAdded: &#39;iceadded&#39;
		},

</code></pre>
						</td>
					</tr>
					<tr id="section_96">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_96">&#182;</a>
							</div>
							<p>Following connection types are supported by <code>xRtc</code> library:</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_97">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_97">&#182;</a>
							</div>
							<ul>
<li><code>default</code>. It is mean standart mechanism of connection establishment. At first trying to establish direct p2p connection without STUN or TURN usage. If previous point is not possible then trying to establish STUN connection. If previous point is not possible then establish TURN connection.</li>
<li><code>direct</code>. It is mean direct p2p or STUN connection establishment.</li>
<li><code>server</code>. It is mean only TURN connection establishment.</li>
</ul>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>		connectionTypes: {
			&#39;default&#39;: &#39;default&#39;,
			direct: &#39;direct&#39;,
			server: &#39;server&#39;
		},

		settings: {
			offerOptions: {
				optional: [],
				mandatory: {
					OfferToReceiveAudio: true,
					OfferToReceiveVideo: true
				}
			},

			answerOptions: {
				optional: [],
				mandatory: {
					OfferToReceiveAudio: true,
					OfferToReceiveVideo: true
				}
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_98">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_98">&#182;</a>
							</div>
							<p>Interop Notes between <em>Chrome M25 and Firefox Nightly (version 21)</em>:
<em>Chrome</em> does not yet do DTLS-SRTP by default whereas <em>Firefox</em> only does DTLS-SRTP. In order to get interop,
you must supply Chrome with a PC constructor constraint to enable DTLS: <code>{ 'optional': [{'DtlsSrtpKeyAgreement': 'true'}]}</code></p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			peerConnectionOptions: {
</code></pre>
						</td>
					</tr>
					<tr id="section_99">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_99">&#182;</a>
							</div>
							<p>optional: [{ RtpDataChannels: true }, { DtlsSrtpKeyAgreement: true }]</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>				optional: [{ RtpDataChannels: !xrtc.webrtc.supports.sctp }, { DtlsSrtpKeyAgreement: true }]
			}
		}
	});

</code></pre>
						</td>
					</tr>
					<tr id="section_100">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_100">&#182;</a>
							</div>
							<p>Cross-browser support: New syntax of <code>getXXXStreams</code> method in <em>Chrome M26</em>.
For <em>FireFox 22</em> <code>webrtc.RTCPeerConnection.prototype</code> is undefined.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>	if (webrtc.RTCPeerConnection.prototype &amp;&amp; !webrtc.RTCPeerConnection.prototype.getLocalStreams) {
		xrtc.Class.extend(webrtc.RTCPeerConnection.prototype, {
			getLocalStreams: function () {
				return this.localStreams;
			},

			getRemoteStreams: function () {
				return this.remoteStreams;
			}
		});
	}

</code></pre>
						</td>
					</tr>
					<tr id="section_101">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_101">&#182;</a>
							</div>
							<p>Cross-browser support: New syntax of <code>getXXXTracks</code> method in <em>Chrome M26</em>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>	if (!webrtc.MediaStream.prototype.getVideoTracks) {
		if (webrtc.detectedBrowser === webrtc.supportedBrowsers.firefox) {
			xrtc.Class.extend(webrtc.MediaStream.prototype, {
				getVideoTracks: function () {
					return [];
				},

				getAudioTracks: function () {
					return [];
				}
			});
		} else {
			xrtc.Class.extend(webrtc.MediaStream.prototype, {
				getVideoTracks: function () {
					return this.videoTracks;
				},

				getAudioTracks: function () {
					return this.audioTracks;
				}
			});
		}
	}

</code></pre>
						</td>
					</tr>
					<tr id="section_102">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_102">&#182;</a>
							</div>
							<p><strong>Todo:</strong> No need to disable data channels in case of communication between <em>FireFox</em> and <em>Firefox</em>. These flags are necessary in case of interoperability between <em>FireFox</em> and <em>Chrome</em> only.
Data channels does't supported in case of interoperability of <em>FireFox</em> and <em>Chrome</em>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>	/*if (webrtc.detectedBrowser === webrtc.supportedBrowsers.firefox) {
</code></pre>
						</td>
					</tr>
					<tr id="section_103">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_103">&#182;</a>
							</div>
							<p><em>Chrome M26b</em> and <em>Chrome Canary</em> with this settings fires an erron on the creation of offer/answer, but it is necessary for interoperablity between <em>FF</em> and <em>Chrome</em>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>		xrtc.Connection.settings.offerOptions.mandatory.MozDontOfferDataChannel = true;
		xrtc.Connection.settings.answerOptions.mandatory.MozDontOfferDataChannel = true;
	}*/
})(window);
</code></pre>
						</td>
					</tr>
			</tbody>
		</table>
	</div>
</body>
</html>
