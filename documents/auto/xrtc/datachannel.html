<!DOCTYPE html />

<html>
<head>
	<title>dataChannel.js</title>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
	<link href="../nocco.css" rel="stylesheet" media="all" type="text/css" />
	<script src="../prettify.js" type="text/javascript"></script>
</head>
<body onload="prettyPrint()">
	<div id="container">
		<div id="background"></div>
			<div id="jump_to">
				Jump To &hellip;
				<div id="jump_wrapper">
					<div id="jump_page">
							<a class="source" href="../xrtc/ajax.html">
								xrtc\ajax.js
							</a>
							<a class="source" href="../xrtc/authmanager.html">
								xrtc\authManager.js
							</a>
							<a class="source" href="../xrtc/class.html">
								xrtc\class.js
							</a>
							<a class="source" href="../xrtc/common.html">
								xrtc\common.js
							</a>
							<a class="source" href="../xrtc/commonerror.html">
								xrtc\commonError.js
							</a>
							<a class="source" href="../xrtc/connection.html">
								xrtc\connection.js
							</a>
							<a class="source" href="../xrtc/datachannel.html">
								xrtc\dataChannel.js
							</a>
							<a class="source" href="../xrtc/eventdispatcher.html">
								xrtc\eventDispatcher.js
							</a>
							<a class="source" href="../xrtc/handshakecontroller.html">
								xrtc\handshakeController.js
							</a>
							<a class="source" href="../xrtc/logger.html">
								xrtc\logger.js
							</a>
							<a class="source" href="../xrtc/room.html">
								xrtc\room.js
							</a>
							<a class="source" href="../xrtc/serverconnector.html">
								xrtc\serverConnector.js
							</a>
							<a class="source" href="../xrtc/stream.html">
								xrtc\stream.js
							</a>
							<a class="source" href="../xrtc/usermedia.html">
								xrtc\userMedia.js
							</a>
					</div>
				</div>
			</div>
		<table cellpadding="0" cellspacing="0">
			<thead>
				<tr>
					<th class="docs">
						<h1>dataChannel.js</h1>
					</th>
					<th class="code"></th>
				</tr>
			</thead>
			<tbody>
					<tr id="section_1">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_1">&#182;</a>
							</div>
							<h4>Version 1.5.0</h4>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_2">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_2">&#182;</a>
							</div>
							<p><code>xRtc.DataChannel</code> is one of the main objects of <strong>xRtc</strong> library. This object can be used for trenferring any information to remote side.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_3">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_3">&#182;</a>
							</div>
							<p><strong>Note:</strong> xRtc 1.4.0 supports only <code>text</code> messages. If <code>object</code> will be used then it will be serialized to <code>text</code> (JSON).</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_4">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_4">&#182;</a>
							</div>
							<p><strong>xRtc 1.4.0 restrictions:</strong></p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_5">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_5">&#182;</a>
							</div>
							<ul>
<li>Message should be less then ~1000 symbols.</li>
<li>Interoperablity between <em>FireFox</em> and <em>Chrome</em> doesn't supported.</li>
</ul>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_6">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_6">&#182;</a>
							</div>
							<p><strong>Dependencies:</strong></p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_7">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_7">&#182;</a>
							</div>
							<ul>
<li>class.js;</li>
<li>eventDispatcher.js;</li>
<li>logger.js;</li>
<li>common.js;</li>
<li>commonError.js.</li>
</ul>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
(function (exports) {
	&#39;use strict&#39;;

	if (typeof exports.xRtc === &#39;undefined&#39;) {
		exports.xRtc = {};
	}

	var xrtc = exports.xRtc;

	xrtc.Class(xrtc, &#39;DataChannel&#39;, function (dataChannel, connection) {
		var proxy = xrtc.Class.proxy(this),
			logger = new xrtc.Logger(this.className),
			events = xrtc.DataChannel.events,
</code></pre>
						</td>
					</tr>
					<tr id="section_8">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_8">&#182;</a>
							</div>
							<p>The original 60000 bytes setting does not work when sending data from Firefox to Chrome, which is "cut off" after 16384 bytes and delivered individually.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			chunkSize = 16300,
</code></pre>
						</td>
					</tr>
					<tr id="section_9">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_9">&#182;</a>
							</div>
							<p>Phases of data sending:</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_10">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_10">&#182;</a>
							</div>
							<ul>
<li>Data will be serialized to binary format;</li>
<li>Data will be chunked to small pieces because Chrome doesn't support large messages;</li>
<li>Each chunk will be serialized to binary format;</li>
<li>Each serilized chunk will be transformed to ArrayBuffer because only this data format supported by all browsers which supports WebRTC;</li>
<li>Sending using buffer. If during sending error will be fired then sending will be repeated little bit later until it will be sent.</li>
</ul>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			sender = new BinarySender(new ChunkedSender(new BinarySender(new ArrayBufferSender(new BufferedSender(dataChannel))), chunkSize)),
			receivedChunks = {};

		dataChannel.onopen = proxy(channelOnOpen);
		dataChannel.onmessage = proxy(channelOnMessage);
</code></pre>
						</td>
					</tr>
					<tr id="section_11">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_11">&#182;</a>
							</div>
							<p><code>dataChannel.onclose</code> tested in case of disconnect(close browser tab) of remote browser for <em>Chrome M29</em>
<strong>Todo:</strong> Need to test onclose event in case of remote client disconnection for <em>Chrome M25-28</em>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>		dataChannel.onclose = proxy(channelOnClose);
		dataChannel.onerror = proxy(channelOnError);
		dataChannel.ondatachannel = proxy(channelOnDatachannel);

		xrtc.Class.extend(this, xrtc.EventDispatcher, {
			_logger: logger,

</code></pre>
						</td>
					</tr>
					<tr id="section_12">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_12">&#182;</a>
							</div>
							<p><strong>[Public API]:</strong> Returns unique data channel id.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			getId: function () {
				return connection.getId() + this.getName();
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_13">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_13">&#182;</a>
							</div>
							<p><strong>[Public API]:</strong> Returns remote user for this data channel.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			getRemoteUser: function () {
				return connection.getRemoteUser();
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_14">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_14">&#182;</a>
							</div>
							<p><strong>[Public API]:</strong> Returns parent connection.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			getConnection: function () {
				return connection;
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_15">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_15">&#182;</a>
							</div>
							<p><strong>[Public API]:</strong> Returns unique <code>name</code> of the data channel.
This <code>name</code> should be specified on <code>createDataChannel(name)</code> method of <code>xRtc.Connection</code> object.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			getName: function () {
				return dataChannel.label;
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_16">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_16">&#182;</a>
							</div>
							<p><strong>[Public API]:</strong> Returns the <code>state</code> of the data channel. Full list of states you can see below.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			getState: function () {
				/* W3C Editor&#39;s Draft 30 August 2013:
				enum RTCDataChannelState {
					&quot;connecting&quot;,
					&quot;open&quot;,
					&quot;closing&quot;,
					&quot;closed&quot;
				};
				*/

				return dataChannel.readyState.toLowerCase();
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_17">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_17">&#182;</a>
							</div>
							<p><strong>[Public API]:</strong> Sends a message to remote user where <code>data</code> is message to send.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			send: function (data) {
				var self = this;

				var currentState = self.getState();
				if (currentState !== xrtc.DataChannel.states.open) {
					var error = new xrtc.CommonError(&#39;send&#39;, &#39;DataChannel should be opened before sending some data. Current channel state is &quot;&#39; + currentState + &#39;&quot;&#39;);
					logger.error(&#39;error&#39;, error);
					self.trigger(events.error, error);
				}

				logger.info(&#39;send&#39;, data);

				sender.send(data);

				self.trigger(events.sentMessage, { data: data });
			}
		});

		function channelOnOpen(evt) {
			var data = { event: evt };
			logger.debug(&#39;open&#39;, data);
			this.trigger(events.open, data);
		};

		function channelOnMessage(evt) {
			var self = this;

			logger.debug(&#39;message&#39;, evt.data);

			var dataType = evt.data.constructor;
			if (dataType === exports.ArrayBuffer) {
				handleIncomingArrayBuffer.call(self, evt.data);
			} else if (dataType === exports.Blob) {
				blobToArrayBufer(evt.data, function(arrayBuffer) {
					handleIncomingArrayBuffer.call(self, arrayBuffer);
				});
			}
		}

		function handleIncomingArrayBuffer(arrayBuffer) {
			var self = this;

			var chunk = xrtc.blobSerializer.unpack(arrayBuffer);
			if (chunk.total === 1) {
				self.trigger(events.receivedMessage, { data: xrtc.blobSerializer.unpack(chunk.data) });
			} else {
				if (!receivedChunks[chunk.blobId]) {
					receivedChunks[chunk.blobId] = { data: [], count: 0, total: chunk.total };
				}

				var blobChunks = receivedChunks[chunk.blobId];
				blobChunks.data[chunk.index] = chunk.data;
				blobChunks.count += 1;

				if (blobChunks.total === blobChunks.count) {
					blobToArrayBufer(new Blob(blobChunks.data), function (arrayBuffer) {
						self.trigger(events.receivedMessage, { data: xrtc.blobSerializer.unpack(arrayBuffer) });
						delete blobChunks[chunk.blobId];
					});
				}
			}
		}

		function channelOnClose(evt) {
			var data = { event: evt };
			logger.debug(&#39;close&#39;, data);
			this.trigger(events.close, data);
		}

		function channelOnError(evt) {
			var error = new xrtc.CommonError(&#39;onerror&#39;, &#39;DataChannel error.&#39;, evt);
			logger.error(&#39;error&#39;, error);
			this.trigger(events.error, error);
		}

		function channelOnDatachannel(evt) {
			var data = { event: evt };
			logger.debug(&#39;datachannel&#39;, data);
			this.trigger(events.dataChannel, data);
		}

	});

	xrtc.DataChannel.extend({
</code></pre>
						</td>
					</tr>
					<tr id="section_18">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_18">&#182;</a>
							</div>
							<p><strong>Note:</strong> Full list of events for the <code>xRtc.DataChannel</code> object.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>		events: {
			open: &#39;open&#39;,
			sentMessage: &#39;sentMessage&#39;,
			receivedMessage: &#39;receivedMessage&#39;,
			close: &#39;close&#39;,
			error: &#39;error&#39;,
			dataChannel: &#39;datachannel&#39;
		},

</code></pre>
						</td>
					</tr>
					<tr id="section_19">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_19">&#182;</a>
							</div>
							<p><strong>Note:</strong> Full list of states of the <code>xRtc.DataChannel</code> object.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>		states: {
			connecting: &quot;connecting&quot;,
			open: &quot;open&quot;,
			closing: &quot;closing&quot;,
			closed: &quot;closed&quot;
		}
	});


</code></pre>
						</td>
					</tr>
					<tr id="section_20">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_20">&#182;</a>
							</div>
							<p>BEGIN Binary Sender</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
	function BinarySender(sender) {
		this._sender = sender;
	}

	BinarySender.prototype.send = function (message) {
		this._sender.send(xrtc.blobSerializer.pack(message));
	};

</code></pre>
						</td>
					</tr>
					<tr id="section_21">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_21">&#182;</a>
							</div>
							<p>END Binary Sender</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
	function blobToArrayBufer(blob, callback) {
		var fileReader = new exports.FileReader();
		fileReader.onload = function (evt) {
			callback(evt.target.result);
		};

		fileReader.readAsArrayBuffer(blob);
	}

</code></pre>
						</td>
					</tr>
					<tr id="section_22">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_22">&#182;</a>
							</div>
							<p>BEGIN ArrayBuffer Sender</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
	function ArrayBufferSender(sender) {
		this._sender = sender;
	}

	ArrayBufferSender.prototype.send = function (blob) {
		var self = this;
		blobToArrayBufer(blob, function (arrayBuffer) {
			self._sender.send(arrayBuffer);
		});
	};

</code></pre>
						</td>
					</tr>
					<tr id="section_23">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_23">&#182;</a>
							</div>
							<p>END ArrayBuffer Sender</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_24">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_24">&#182;</a>
							</div>
							<p>BEGIN Chunked Sender</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
	function ChunkedSender(sender, chunkSize) {
		this._sender = sender;
		this.chunkSize = chunkSize;
	}

	ChunkedSender.prototype.send = function (blob) {
		this._sendChunks(this._splitToChunks(blob));
	};

	ChunkedSender.prototype._splitToChunks = function (blob) {
		var blobId = xRtc.utils.newGuid(),
			chunks = [],
			size = blob.size,
			start = 0,
			index = 0,
			total = Math.ceil(size / this.chunkSize);

		while (start &lt; size) {
			var end = Math.min(size, start + this.chunkSize);

			var chunk = {
				blobId: blobId,
				index: index,
				data: blob.slice(start, end),
				total: total
			};

			chunks.push(chunk);

			start = end;
			index += 1;
		}

		return chunks;
	};

	ChunkedSender.prototype._sendChunks = function (chunks) {
		for (var i = 0, len = chunks.length; i &lt; len; i += 1) {
			this._sender.send(chunks[i]);
		}
	};

</code></pre>
						</td>
					</tr>
					<tr id="section_25">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_25">&#182;</a>
							</div>
							<p>END Chunked Sender</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_26">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_26">&#182;</a>
							</div>
							<p>BEGIN Buffer Sender</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
	function BufferedSender(sender) {
		this._sender = sender;
		this._buffer = [];
		this._sendImmediately = true;
	}

	BufferedSender.prototype.send = function (message) {
		this._buffer.push(message);
		this._sendBuffer(this._buffer);
	};

	BufferedSender.prototype._sendBuffer = function (buffer) {
		var self = this;
		if (self._sendImmediately) {
			if (!self._trySendBuffer(buffer)) {
				self._sendImmediately = false;
				exports.setTimeout(function () {
					self._sendImmediately = true;
					self._sendBuffer(buffer);
				}, 100);
			}
		}
	};

	BufferedSender.prototype._trySendBuffer = function (buffer) {
		if (buffer.length === 0) {
			return true;
		}

		if (this._trySend(buffer[0])) {
			buffer.shift();
			return this._trySendBuffer(buffer);
		} else {
			return false;
		}
	};

	BufferedSender.prototype._trySend = function (message) {
		try {
			this._sender.send(message);
			return true;
		} catch (ex) {
			return false;
		}
	};

</code></pre>
						</td>
					</tr>
					<tr id="section_27">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_27">&#182;</a>
							</div>
							<p>END Buffer Sender</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>})(window);
</code></pre>
						</td>
					</tr>
			</tbody>
		</table>
	</div>
</body>
</html>
