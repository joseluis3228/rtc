<!DOCTYPE html />

<html>
<head>
	<title>DataChannel.js</title>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
	<link href="../nocco.css" rel="stylesheet" media="all" type="text/css" />
	<script src="../prettify.js" type="text/javascript"></script>
</head>
<body onload="prettyPrint()">
	<div id="container">
		<div id="background"></div>
			<div id="jump_to">
				Jump To &hellip;
				<div id="jump_wrapper">
					<div id="jump_page">
							<a class="source" href="../xrtc/ajax.html">
								xrtc\Ajax.js
							</a>
							<a class="source" href="../xrtc/authmanager.html">
								xrtc\AuthManager.js
							</a>
							<a class="source" href="../xrtc/class.html">
								xrtc\Class.js
							</a>
							<a class="source" href="../xrtc/common.html">
								xrtc\Common.js
							</a>
							<a class="source" href="../xrtc/commonerror.html">
								xrtc\CommonError.js
							</a>
							<a class="source" href="../xrtc/connection.html">
								xrtc\Connection.js
							</a>
							<a class="source" href="../xrtc/datachannel.html">
								xrtc\DataChannel.js
							</a>
							<a class="source" href="../xrtc/eventdispatcher.html">
								xrtc\EventDispatcher.js
							</a>
							<a class="source" href="../xrtc/handshakecontroller.html">
								xrtc\HandshakeController.js
							</a>
							<a class="source" href="../xrtc/logger.html">
								xrtc\Logger.js
							</a>
							<a class="source" href="../xrtc/room.html">
								xrtc\Room.js
							</a>
							<a class="source" href="../xrtc/serverconnector.html">
								xrtc\ServerConnector.js
							</a>
							<a class="source" href="../xrtc/stream.html">
								xrtc\Stream.js
							</a>
							<a class="source" href="../xrtc/usermedia.html">
								xrtc\UserMedia.js
							</a>
					</div>
				</div>
			</div>
		<table cellpadding="0" cellspacing="0">
			<thead>
				<tr>
					<th class="docs">
						<h1>DataChannel.js</h1>
					</th>
					<th class="code"></th>
				</tr>
			</thead>
			<tbody>
					<tr id="section_1">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_1">&#182;</a>
							</div>
							<h4>Version 1.5.0</h4>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_2">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_2">&#182;</a>
							</div>
							<p><code>xRtc.DataChannel</code> is one of the main objects of <strong>xRtc</strong> library. This object can be used for trenferring any information to remote side.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_3">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_3">&#182;</a>
							</div>
							<p><em>* Supported browsers:</em>*</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_4">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_4">&#182;</a>
							</div>
							<ul>
<li>Chrome 25+;</li>
<li>FireFox 22+;</li>
<li>Opera 17+ (Chromium).</li>
</ul>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_5">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_5">&#182;</a>
							</div>
							<p><em>* Restrictions:</em>*</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_6">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_6">&#182;</a>
							</div>
							<ul>
<li>Reliable channels and possibility to transfer files (sctp protocol) supported only by FireFox 22+, Chrome 31+, Opera 19+;</li>
<li>Following types can be sended via data channels (All types which supported by BinaryPack library (binarypack.js)).
Simple types: <code>string</code>, <code>number</code>, <code>boolean</code>, <code>undefined</code>.
Object types: <code>Array</code>, <code>Blob</code>, <code>File</code>, <code>ArrayBuffer</code>, <code>Date</code>, <code>Object</code>.</li>
</ul>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_7">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_7">&#182;</a>
							</div>
							<p><em>* Interoperability cases which works:</em>*</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_8">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_8">&#182;</a>
							</div>
							<ul>
<li>Chrome 25-31 to Chrome 25-31;</li>
<li>Chrome 25-31 to Opera 17;</li>
<li>Chrome 32+ to Chrome 32+;</li>
<li>Chrome 32+ to FireFox 26+;</li>
</ul>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_9">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_9">&#182;</a>
							</div>
							<ul>
<li>FireFox 22+ to FireFox 22+;</li>
<li>FireFox 26+ to Chrome 32+;</li>
</ul>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_10">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_10">&#182;</a>
							</div>
							<ul>
<li>Opera 17 to Opera 17;</li>
<li>Opera 17 to Chrome 25-31;</li>
<li>Opera 18 to Opera 18;</li>
<li>Opera 19 to Opera 19.</li>
</ul>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_11">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_11">&#182;</a>
							</div>
							<p><strong>Todo: Need to test it and created interoperability table. E.g. Opera didn't teste almost in interoperability mode.</strong></p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_12">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_12">&#182;</a>
							</div>
							<p><strong>Dependencies:</strong></p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_13">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_13">&#182;</a>
							</div>
							<ul>
<li>class.js;</li>
<li>eventDispatcher.js;</li>
<li>logger.js;</li>
<li>common.js;</li>
<li>commonError.js.</li>
</ul>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
(function (exports) {
	&#39;use strict&#39;;

	if (typeof exports.xRtc === &#39;undefined&#39;) {
		exports.xRtc = {};
	}

	var xrtc = exports.xRtc;

	xrtc.Class(xrtc, &#39;DataChannel&#39;, function (dataChannel, connection) {
		var proxy = xrtc.Class.proxy(this),
			logger = new xrtc.Logger(this.className),
			events = xrtc.DataChannel.events,
			transferringProgressInterval = 10, /*In packets, 1Mb ~ 64 packets if packet size is 16300 bytes*/
</code></pre>
						</td>
					</tr>
					<tr id="section_14">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_14">&#182;</a>
							</div>
							<p>The original 60000 bytes setting does not work when sending data from Firefox to Chrome, which is "cut off" after 16384 bytes and delivered individually.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			chunkSize = 16300, /*bytes*/
			attemptsMaxCount = 100,
</code></pre>
						</td>
					</tr>
					<tr id="section_15">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_15">&#182;</a>
							</div>
							<p>Phases of data sending:</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_16">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_16">&#182;</a>
							</div>
							<ul>
<li>Data will be serialized to binary format;</li>
<li>Data will be chunked to small pieces because Chrome doesn't support large messages;</li>
<li>Each chunk will be serialized to binary format;</li>
<li>Each serilized chunk will be transformed to ArrayBuffer because only this data format supported by all browsers which supports WebRTC;</li>
<li>Sending using buffer. If during sending error will be fired then sending will be repeated little bit later until it will be sent.</li>
</ul>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			sender = new BinarySender(new ChunkedSender(new BinarySender(new ArrayBufferSender(new BufferedSender(dataChannel, attemptsMaxCount))), chunkSize)),
			receivedChunks = {};

		dataChannel.onopen = proxy(channelOnOpen);
		dataChannel.onmessage = proxy(channelOnMessage);
</code></pre>
						</td>
					</tr>
					<tr id="section_17">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_17">&#182;</a>
							</div>
							<p><code>dataChannel.onclose</code> tested in case of disconnect(close browser tab) of remote browser for <em>Chrome M29</em>
<strong>Todo:</strong> Need to test onclose event in case of remote client disconnection for <em>Chrome M25-28</em>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>		dataChannel.onclose = proxy(channelOnClose);
		dataChannel.onerror = proxy(channelOnError);
		dataChannel.ondatachannel = proxy(channelOnDatachannel);

		xrtc.Class.extend(this, xrtc.EventDispatcher, {
			_logger: logger,

</code></pre>
						</td>
					</tr>
					<tr id="section_18">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_18">&#182;</a>
							</div>
							<p><strong>[Public API]:</strong> Returns unique data channel id.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			getId: function () {
				return connection.getId() + this.getName();
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_19">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_19">&#182;</a>
							</div>
							<p><strong>[Public API]:</strong> Returns remote user for this data channel.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			getRemoteUser: function () {
				return connection.getRemoteUser();
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_20">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_20">&#182;</a>
							</div>
							<p><strong>[Public API]:</strong> Returns parent connection.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			getConnection: function () {
				return connection;
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_21">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_21">&#182;</a>
							</div>
							<p><strong>[Public API]:</strong> Returns unique <code>name</code> of the data channel.
This <code>name</code> should be specified on <code>createDataChannel(name)</code> method of <code>xRtc.Connection</code> object.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			getName: function () {
				return dataChannel.label;
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_22">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_22">&#182;</a>
							</div>
							<p><strong>[Public API]:</strong> Returns the <code>state</code> of the data channel. Full list of states you can see below.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			getState: function () {
				/* W3C Editor&#39;s Draft 30 August 2013:
				enum RTCDataChannelState {
					&quot;connecting&quot;,
					&quot;open&quot;,
					&quot;closing&quot;,
					&quot;closed&quot;
				};
				*/

				return dataChannel.readyState.toLowerCase();
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_23">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_23">&#182;</a>
							</div>
							<p><strong>[Public API]:</strong> Sends a message to remote user where <code>msg</code> is message to send.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			send: function (msg, successCallback, failCallback, options /*{ messageId }*/) {
				var self = this;

				var currentState = self.getState();
				if (currentState !== xrtc.DataChannel.states.open) {
					var incorrectStateError = new xrtc.CommonError(&#39;send&#39;, &#39;DataChannel should be opened before sending some data. Current channel state is &quot;&#39; + currentState + &#39;&quot;&#39;);
					logger.error(&#39;error&#39;, incorrectStateError);
					self.trigger(events.error, incorrectStateError);
				}

				logger.info(&#39;send&#39;, msg);

				sender.send(
					msg,
					function () {
						var evt = { data: msg };
						if (typeof successCallback === &quot;function&quot;) {
							successCallback(evt);
						}

						self.trigger(events.sentMessage, evt);
					},
					function (evt) {
						var sendError = new xrtc.CommonError(&#39;send&#39;, &#39;DataChannel error.&#39;, evt);
						logger.error(&#39;error&#39;, sendError);

						if (typeof failCallback === &quot;function&quot;) {
							failCallback(sendError);
						}

						self.trigger(events.error, sendError);
					},
					function (evt) {
						if (evt.count % transferringProgressInterval === 0 || evt.count === evt.total) {
							var progressEvent = {
								messageId: evt.messageId,
								percent: 100 * evt.count / evt.total,
								cancel: function () {
</code></pre>
						</td>
					</tr>
					<tr id="section_24">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_24">&#182;</a>
							</div>
							<p><strong>Todo:</strong> Need to implement.
<strong>Idea:</strong> Stop the chunks sending and send special message about stopping/cancelling.
When special message about stopping/cancelling will be received by remote client then already received chunks should be deleted.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>									throw &quot;Not implemented yet.&quot;;
								}
							};
							self.trigger(events.progress, progressEvent);
						}
					},
					options &amp;&amp; options.messageId ? { messageId: options.messageId } : null);
			}
		});

		function channelOnOpen(evt) {
			var data = { event: evt };
			logger.debug(&#39;open&#39;, data);
			this.trigger(events.open, data);
		};

		function channelOnMessage(evt) {
			var self = this;

			logger.debug(&#39;message&#39;, evt.data);

			var dataType = evt.data.constructor;
			if (dataType === exports.ArrayBuffer) {
				handleIncomingArrayBuffer.call(self, evt.data);
			} else if (dataType === exports.Blob) {
				blobToArrayBuffer(evt.data, function (arrayBuffer) {
					handleIncomingArrayBuffer.call(self, arrayBuffer);
				});
			}
		}

		function handleIncomingArrayBuffer(arrayBuffer) {
			var self = this;

			var chunk = xrtc.blobSerializer.unpack(arrayBuffer);
			if (chunk.total === 1) {
				self.trigger(events.receivedMessage, { data: xrtc.blobSerializer.unpack(chunk.data) });
			} else {
				if (!receivedChunks[chunk.messageId]) {
					receivedChunks[chunk.messageId] = { data: [], count: 0, total: chunk.total };
				}

				var blobChunks = receivedChunks[chunk.messageId];
				blobChunks.data[chunk.index] = chunk.data;
				blobChunks.count += 1;

				if (blobChunks.count % transferringProgressInterval === 0 || blobChunks.total === blobChunks.count) {
					var progressEvt = {
						messageId: chunk.messageId,
						percent: 100 * blobChunks.count / blobChunks.total,
						cancel: function() {
</code></pre>
						</td>
					</tr>
					<tr id="section_25">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_25">&#182;</a>
							</div>
							<p><strong>Todo:</strong> Need to implement.
<strong>Idea:</strong> Send special 'cancellation' message to sender.
Sendre will stop the chunks sending and send special message about stopping/cancelling.
When special message about stopping/cancelling will be received then need to delted already received chunks.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>							throw &quot;Not implemented yet.&quot;;
						}
					};
					self.trigger(events.progress, progressEvt);
				}

				if (blobChunks.total === blobChunks.count) {
					blobToArrayBuffer(new exports.Blob(blobChunks.data), function (ab) {
						self.trigger(events.receivedMessage, { data: xrtc.blobSerializer.unpack(ab) });
						delete blobChunks[chunk.messageId];
					});
				}
			}
		}

		function channelOnClose(evt) {
			var data = { event: evt };
			logger.debug(&#39;close&#39;, data);
			this.trigger(events.close, data);
		}

		function channelOnError(evt) {
			var error = new xrtc.CommonError(&#39;onerror&#39;, &#39;DataChannel error.&#39;, evt);
			logger.error(&#39;error&#39;, error);
			this.trigger(events.error, error);
		}

		function channelOnDatachannel(evt) {
			var data = { event: evt };
			logger.debug(&#39;datachannel&#39;, data);
			this.trigger(events.dataChannel, data);
		}

	});

	xrtc.DataChannel.extend({
</code></pre>
						</td>
					</tr>
					<tr id="section_26">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_26">&#182;</a>
							</div>
							<p><strong>Note:</strong> Full list of events for the <code>xRtc.DataChannel</code> object.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>		events: {
			open: &#39;open&#39;,
</code></pre>
						</td>
					</tr>
					<tr id="section_27">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_27">&#182;</a>
							</div>
							<p><strong>Todo:</strong> Need to add possibility to cancel message sending/receiving on <code>progress</code> event.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			progress: &#39;progress&#39;,
			sentMessage: &#39;sentMessage&#39;,
			receivedMessage: &#39;receivedMessage&#39;,
			close: &#39;close&#39;,
			error: &#39;error&#39;,
			dataChannel: &#39;datachannel&#39;
		},

</code></pre>
						</td>
					</tr>
					<tr id="section_28">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_28">&#182;</a>
							</div>
							<p><strong>Note:</strong> Full list of states of the <code>xRtc.DataChannel</code> object.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>		states: {
			connecting: &quot;connecting&quot;,
			open: &quot;open&quot;,
			closing: &quot;closing&quot;,
			closed: &quot;closed&quot;
		}
	});


</code></pre>
						</td>
					</tr>
					<tr id="section_29">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_29">&#182;</a>
							</div>
							<p>BEGIN Binary Sender</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
	function BinarySender(sender) {
		this._sender = sender;
	}

	BinarySender.prototype.send = function (message, successCallback, failCallback, progressCallback, options) {
		this._sender.send(xrtc.blobSerializer.pack(message), successCallback, failCallback, progressCallback, options);
	};

</code></pre>
						</td>
					</tr>
					<tr id="section_30">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_30">&#182;</a>
							</div>
							<p>END Binary Sender</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
	function blobToArrayBuffer(blob, callback) {
		var fileReader = new exports.FileReader();
		fileReader.onload = function (evt) {
			callback(evt.target.result);
		};

		fileReader.readAsArrayBuffer(blob);
	}

</code></pre>
						</td>
					</tr>
					<tr id="section_31">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_31">&#182;</a>
							</div>
							<p>BEGIN Chunked Sender</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
	function ChunkedSender(sender, chunkSize) {
		this._sender = sender;
		this.chunkSize = chunkSize;
	}

	ChunkedSender.prototype.send = function (blob, successCallback, failCallback, progressCallback, options) {
		this._sendChunks(this._splitToChunks(blob, options), successCallback, failCallback, progressCallback);
	};

	ChunkedSender.prototype._splitToChunks = function (blob, options) {
		var messageId = options &amp;&amp; options.messageId ? options.messageId : xRtc.utils.newGuid(),
			chunks = [],
			size = blob.size,
			start = 0,
			index = 0,
			total = Math.ceil(size / this.chunkSize);

		while (start &lt; size) {
			var end = Math.min(size, start + this.chunkSize);

			var chunk = {
				messageId: messageId,
				index: index,
				data: blob.slice(start, end),
				total: total
			};

			chunks.push(chunk);

			start = end;
			index += 1;
		}

		return chunks;
	};

	ChunkedSender.prototype._sendChunks = function (chunks, successCallback, failCallback, progressCallback) {
		var self = this;

		if (chunks.length === 0) {
			if (typeof successCallback === &quot;function&quot;) {
				successCallback();
			}

			return;
		}

		var firstChunk = chunks.shift();

		this._sender.send(
			firstChunk,
			function () {
				if (typeof progressCallback === &quot;function&quot;) {
					progressCallback({ messageId: firstChunk.messageId, count: firstChunk.index + 1, total: firstChunk.total });
				}

				self._sendChunks(chunks, successCallback, failCallback, progressCallback);
			},
			failCallback);
	};

</code></pre>
						</td>
					</tr>
					<tr id="section_32">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_32">&#182;</a>
							</div>
							<p>END Chunked Sender</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_33">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_33">&#182;</a>
							</div>
							<p>BEGIN ArrayBuffer Sender</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
	function ArrayBufferSender(sender) {
		this._sender = sender;
	}

	ArrayBufferSender.prototype.send = function (blob, successCallback, failCallback) {
		var self = this;
		blobToArrayBuffer(blob, function (arrayBuffer) {
			self._sender.send(arrayBuffer, successCallback, failCallback);
		});
	};

</code></pre>
						</td>
					</tr>
					<tr id="section_34">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_34">&#182;</a>
							</div>
							<p>END ArrayBuffer Sender</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_35">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_35">&#182;</a>
							</div>
							<p>BEGIN Buffered Sender</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
	function BufferedSender(sender, attemptsMaxCount) {
		this._sender = sender;
		this._attemptsMaxCount = attemptsMaxCount;
		this._buffer = [];
		this._sendImmediately = true;
	}

	BufferedSender.prototype.send = function (message, successCallback, failCallback) {
		this._buffer.push(message);
		this._sendBuffer(this._buffer, successCallback, failCallback, 0);
	};

	BufferedSender.prototype._sendBuffer = function (buffer, successCallback, failCallback, attemptCounter) {
		var self = this;

		var attemptsExceeded = function (ex) {
			if (attemptCounter === self._attemptsMaxCount &amp;&amp; typeof failCallback === &quot;function&quot;) {
				failCallback(ex);
			}
		};

		if (self._sendImmediately) {
			if (!self._trySendBuffer(buffer, successCallback, attemptsExceeded, attemptCounter)) {
				if (attemptCounter &lt; self._attemptsMaxCount) {
					self._sendImmediately = false;

					exports.setTimeout(function () {
						self._sendImmediately = true;
						self._sendBuffer(buffer, successCallback, failCallback, ++attemptCounter);
					}, 100);
				} else {

				}
			}
		}
	};

	BufferedSender.prototype._trySendBuffer = function (buffer, successCallback, failCallback) {
		if (buffer.length === 0) {
			return true;
		}

		if (this._trySend(buffer[0], successCallback, failCallback)) {
			buffer.shift();
			return this._trySendBuffer(buffer, successCallback, failCallback);
		} else {
			return false;
		}
	};

	BufferedSender.prototype._trySend = function (message, successCallback, failCallback) {
		try {
			this._sender.send(message);
		} catch (ex) {
			failCallback(ex);
			return false;
		}

		if (typeof successCallback === &quot;function&quot;) {
			successCallback();
		}
		return true;
	};

</code></pre>
						</td>
					</tr>
					<tr id="section_36">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_36">&#182;</a>
							</div>
							<p>END Buffered Sender</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>})(window);
</code></pre>
						</td>
					</tr>
			</tbody>
		</table>
	</div>
</body>
</html>
