<!DOCTYPE html />

<html>
<head>
	<title>Connection.js</title>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
	<link href="../nocco.css" rel="stylesheet" media="all" type="text/css" />
	<script src="../prettify.js" type="text/javascript"></script>
</head>
<body onload="prettyPrint()">
	<div id="container">
		<div id="background"></div>
		<table cellpadding="0" cellspacing="0">
			<thead>
				<tr>
					<th class="docs">
						<h1>Connection.js</h1>
					</th>
					<th class="code"></th>
				</tr>
			</thead>
			<tbody>
					<tr id="section_1">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_1">&#182;</a>
							</div>
							<h4>Version 1.3.0</h4>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_2">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_2">&#182;</a>
							</div>
							<p><code>xRtc.Connection</code> is one of the main objects of <strong>xRtc</strong> library. This object can not be created manually.
For the creation of connection need to use <code>xRtc.Room</code> object.
The main goal of this object is handling real p2p connection.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
&#39;use strict&#39;;

(function (exports) {
	var xrtc = exports.xRtc,
		internal = {},
		webrtc = xrtc.webrtc;

</code></pre>
						</td>
					</tr>
					<tr id="section_3">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_3">&#182;</a>
							</div>
							<p><code>IceCandidateFilter</code> is internal object of <code>xRtc.Connection</code>. The object contains functionality which helps to filter webrtc ice candidates in case if <code>server</code> or <code>direct</code> connection is required.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>	xrtc.Class(internal, &#39;IceCandidateFilter&#39;, function IceCandidateFilter(type, is) {
		var proxy = xrtc.Class.proxy(this),
			logger = new xrtc.Logger(this.className),
			connectionType = type || xrtc.Connection.connectionTypes.default,
			iceServers = is &amp;&amp; is.iceServers || null,
			ipRegexp = /(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/g;

		xrtc.Class.extend(this, {
</code></pre>
						</td>
					</tr>
					<tr id="section_4">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_4">&#182;</a>
							</div>
							<p>Returns type of the current connection.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			getType: function () {
				return connectionType;
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_5">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_5">&#182;</a>
							</div>
							<p>Returns boolean value which means <code>ice</code> corresponds current connection type or not.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			isAllowed: function (ice) {
				var result = true;

				switch (connectionType) {
					case xrtc.Connection.connectionTypes.direct:
						result = iceCandidatesFilters.local(ice) || iceCandidatesFilters.stun(ice);
						break;
					case xrtc.Connection.connectionTypes.server:
						if (iceCandidatesFilters.stun(ice)) {
							iceCandidateConverters.stun2turn(ice);
						} else if (iceCandidatesFilters.turn(ice)) {
							iceCandidateConverters.turn2turn(ice);
						} else {
							result = false;
						}
						break;
					default:
						break;
				}

				return result;
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_6">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_6">&#182;</a>
							</div>
							<p>Returns <code>sdp</code> which corrected accordingly current connection type.
<strong>Note:</strong> FireFox <code>offer</code> and <code>answer</code> contains all ice candidates which should be deleted if connection type is <code>server</code> (equals <code>xrtc.Connection.connectionTypes.server</code>).</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			filterSDP: function (sdp) {
				var changedSdp = sdp;
				if (connectionType === xrtc.Connection.connectionTypes.server) {
</code></pre>
						</td>
					</tr>
					<tr id="section_7">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_7">&#182;</a>
							</div>
							<p>This regex removes from <code>sdp</code> all direct p2p <code>host</code> and STUN <code>srflx</code> ice candidates from the <code>sdp</code>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>					changedSdp = sdp.replace(/a=candidate:.*((typ host)|(typ srflx)).*\r\n/g, &quot;&quot;);
				} else if (connectionType === xrtc.Connection.connectionTypes.direct) {
</code></pre>
						</td>
					</tr>
					<tr id="section_8">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_8">&#182;</a>
							</div>
							<p>This regex removes from <code>sdp</code> all TURN <code>relay</code> ice candidates from the <code>sdp</code>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>					changedSdp = sdp.replace(/a=candidate:.*typ relay.*\r\n/g, &quot;&quot;);
				}

				return changedSdp;
			}
		});

</code></pre>
						</td>
					</tr>
					<tr id="section_9">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_9">&#182;</a>
							</div>
							<p>Internal candidate filters.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>		var iceCandidatesFilters = {
</code></pre>
						</td>
					</tr>
					<tr id="section_10">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_10">&#182;</a>
							</div>
							<p>Returns function which filters direct p2p <code>host</code> ice candidates.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			local: function (iceCandidate) {
				var regexp = /typ host/;

				return filterIceCandidate(iceCandidate, regexp);
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_11">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_11">&#182;</a>
							</div>
							<p>Returns function which filters STUN <code>srflx</code> ice candidates.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			stun: function (iceCandidate) {
				var regexp = /typ srflx/;

				return filterIceCandidate(iceCandidate, regexp);
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_12">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_12">&#182;</a>
							</div>
							<p>Returns function which filters TURN <code>relay</code> ice candidates.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			turn: function (iceCandidate) {
				var regexp = /typ relay/;

				return filterIceCandidate(iceCandidate, regexp);
			}
		};

		function filterIceCandidate(iceCandidate, regexp) {
			return regexp.test(iceCandidate.candidate);
		}

</code></pre>
						</td>
					</tr>
					<tr id="section_13">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_13">&#182;</a>
							</div>
							<p><strong>Todo:</strong> My be bug. Need to fix it because at the current moment 2 types of presentation TURN server exists. One of them doesn't contain <code>@</code>.
Returns IP address of the TURN server which stores in the local variable <code>iceServers</code>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>		function getTurnIp() {
			if (iceServers) {
				for (var i = 0; i &lt; iceServers.length; i++) {
					var server = iceServers[i];
					if (&#39;credential&#39; in server) {
						return server.url.split(&#39;@&#39;)[1];
					}

				}
			}
			return null;
		}

</code></pre>
						</td>
					</tr>
					<tr id="section_14">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_14">&#182;</a>
							</div>
							<p>Internal ice candidate converters which can convert one ice candidates to another. Sometimes browser check connection with STUN and doesn't generate TURN ice candidates. In this case we create own TURN ice candidates using STUN ice candidates.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>		var iceCandidateConverters = {
</code></pre>
						</td>
					</tr>
					<tr id="section_15">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_15">&#182;</a>
							</div>
							<p><strong>Todo:</strong> Need to clarify/test existence of this method.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			turn2turn: function (iceCandidate) {
				iceCandidate.candidate = iceCandidate.candidate.replace(ipRegexp, iceCandidate.candidate.match(ipRegexp)[0]);
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_16">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_16">&#182;</a>
							</div>
							<p>Creates TURN ice candidate using STUN ice candidate.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			stun2turn: function (iceCandidate) {
				var turnIp = getTurnIp();
				if (turnIp) {
					iceCandidate.candidate = iceCandidate.candidate.replace(ipRegexp, turnIp);
				} else {
</code></pre>
						</td>
					</tr>
					<tr id="section_17">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_17">&#182;</a>
							</div>
							<p><strong>Todo:</strong> Is it right?</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>					iceCandidateConverters.turn2turn(iceCandidate);
				}
			}
		};
	});

</code></pre>
						</td>
					</tr>
					<tr id="section_18">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_18">&#182;</a>
							</div>
							<p><strong>Todo:</strong> Need to optimize the constructor sugnature of Connection object.
It is internal constructor . The <code>xRtc.Room</code> object uses this constructor for creation connections objects.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>	xrtc.Class(xrtc, &#39;Connection&#39;, function Connection(ud, targetId, hc, am, data) {
		var proxy = xrtc.Class.proxy(this),
			logger = new xrtc.Logger(this.className),
			userData = ud,
			authManager = am || new xRtc.AuthManager(),
			remoteUserId = targetId,
			remoteConnectionId = null,
			localStreams = [],
			remoteStreams = [],
			dataChannels = [],
			dataChannelNames = [],
			peerConnection = null,
			checkConnectionStateIntervalId = null,
			checkDisconnectedIceStateTimeoutId = null,
			handshakeController = hc,
			iceFilter = null,
			iceServers = null,
</code></pre>
						</td>
					</tr>
					<tr id="section_19">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_19">&#182;</a>
							</div>
							<p>This field is used to determine whether the coonection was accepted and need to send ice candidates to remote application.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			connectionEstablished = false,
</code></pre>
						</td>
					</tr>
					<tr id="section_20">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_20">&#182;</a>
							</div>
							<p>It is tempoprary storage of ice candidates.
Ice candidates should be send to remote participant after receiving <code>answer</code> strictly.
If the application will send ice candidates after <code>offer</code> sending then it can be skipped by remote application
because there is no guarantee of connection establishing and while the application/user will be thinking
about accept/decline incoming connection these ice candidates reach it and will be skipped,
because the remote peerConnection still not created.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			iceCandidates = [],
			connectionId = generateGuid(),
</code></pre>
						</td>
					</tr>
					<tr id="section_21">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_21">&#182;</a>
							</div>
							<p>Internal user data conainer. The data helps to identify the connection and differ the connection from other connections.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			connectionData = data,
			connectionIsOpened = false;

		subscribeToHandshakeControllerEvents.call(this);

		xrtc.Class.extend(this, xrtc.EventDispatcher, {
			_logger: logger,

			getId: function () {
				return connectionId;
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_22">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_22">&#182;</a>
							</div>
							<p>It is internal method. It should not be used manually.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			_open: function (options) {
				connectionIsOpened = true;

				var self = this,
					offerOptions = {};

</code></pre>
						</td>
					</tr>
					<tr id="section_23">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_23">&#182;</a>
							</div>
							<p>offerOptions field initialization.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>				xrtc.Class.extend(offerOptions, xrtc.Connection.settings.offerOptions);
				if (options &amp;&amp; options.offer) {
					xrtc.Class.extend(offerOptions, options.offer);
				}

				self.trigger(xrtc.Connection.events.connectionOpening, { sender: self, userId: remoteUserId });

				initPeerConnection.call(self, remoteUserId, function () {
					iceFilter = new internal.IceCandidateFilter(options &amp;&amp; options.connectionType || null, iceServers);

					peerConnection.createOffer(proxy(onCreateOfferSuccess), proxy(onCreateOfferError), offerOptions);

					function onCreateOfferSuccess(offer) {
						if (webrtc.detectedBrowser === webrtc.supportedBrowsers.firefox) {
							offer.sdp = iceFilter.filterSDP(offer.sdp);
						}

						logger.debug(&#39;onCreateOfferSuccess&#39;, offer);
						peerConnection.setLocalDescription(offer);

</code></pre>
						</td>
					</tr>
					<tr id="section_24">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_24">&#182;</a>
							</div>
							<p>This magis is required for interoperability support of FF21 and Chrome.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>						if (webrtc.detectedBrowser === webrtc.supportedBrowsers.firefox &amp;&amp; webrtc.detectedBrowserVersion &lt;= 21) {
							var inline = &#39;a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:FakeFakeFakeFakeFakeFakeFakeFakeFakeFake\r\nc=IN&#39;;
							offer.sdp = offer.sdp.indexOf(&#39;a=crypto&#39;) == -1 ? offer.sdp.replace(/c=IN/g, inline) : offer.sdp;
						}

						var request = {
							offer: JSON.stringify(offer),
							connectionData: connectionData,
							connectionType: iceFilter.getType(),
							iceServers: iceServers
						};

						logger.debug(&#39;sendOffer&#39;, remoteUserId, offer);
						handshakeController.sendOffer(remoteUserId, remoteConnectionId, connectionId, request);
						self.trigger(xrtc.Connection.events.offerSent, { userId: remoteUserId, offerData: request });
					}

					function onCreateOfferError(err) {
						var error = new xrtc.CommonError(&#39;startSession&#39;, &quot;Cannot create WebRTC offer&quot;, err);

						logger.error(&#39;onCreateOfferError&#39;, error);
						self.trigger(xrtc.Connection.events.createOfferError, error);
					}
				});
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_25">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_25">&#182;</a>
							</div>
							<p><strong>[Public API]:</strong> It is public method of <code>connection</code> object. This method should be used for closing the <code>connection</code>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			close: function () {
				if (handshakeController &amp;&amp; remoteUserId &amp;&amp; remoteConnectionId) {
					handshakeController.sendBye(remoteUserId, remoteConnectionId, connectionId);
				}

				closePeerConnection.call(this);
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_26">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_26">&#182;</a>
							</div>
							<p><strong>[Public API]:</strong> It is public method of <code>connection</code> object. This method should be used for adding <code>xRtc.Stream</code> to the <code>connection</code>.
It is required if you want to transmit the <code>stream</code> to remote user. The <code>xRtc.Stream</code> can be obtained using <code>xRtc.getUserMedia</code> method.
One <code>connection</code> can be used for transfering some streams to remote side.
After execution this method <code>localstreamadded</code> (<code>xrtc.Connection.events.localStreamAdded</code>) event of connection object will be fired.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			addStream: function (xrtcStream) {
				if (connectionIsOpened) {
					throwExceptionOfWrongmethodCall(&#39;addStream&#39;);
				}

				localStreams.push(xrtcStream);

				var streamData = {
					stream: xrtcStream,
					userId: userData.name
				};

				logger.debug(&#39;addLocalStream&#39;, streamData);
				this.trigger(xrtc.Connection.events.localStreamAdded, streamData);
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_27">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_27">&#182;</a>
							</div>
							<p><strong>[Public API]:</strong> It is public method of <code>connection</code> object. This method should be used for creating <code>xRtc.DataChannel</code> for the <code>connection</code>.
Names of the data channels should be unique in context of any <code>connection</code>.
<em>*Note: *</em> This method can be used only on <code>connectionCreated</code> (<code>xRtc.Room.events.connectionCreated</code>) event of the <code>xRtc.Room</code> object otherwise exception will be thrown.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			createDataChannel: function (name) {
				if (connectionIsOpened) {
					throwExceptionOfWrongmethodCall(&#39;createDataChannel&#39;);
				}

				dataChannelNames.push(name);
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_28">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_28">&#182;</a>
							</div>
							<p><strong>[Public API]:</strong> It is public method of <code>connection</code> object. This method should be used for accessing 'specific user data' of the connection.
User/Developer can pass any data to the 'connection' in the `xRtc.Room.connect()' method. E.g. This functionality will be useful
if need to differ one connection from another because 'xRtc.Room' creates connections asynchronously.
Also it will be useful if you want to store some data which related with concrete 'connection' object.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			getData: function () {
				return connectionData;
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_29">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_29">&#182;</a>
							</div>
							<p><strong>[Public API]:</strong> It is public method of <code>connection</code> object. Returns state of the <code>connection</code>.
List of possibly connection states:</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_30">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_30">&#182;</a>
							</div>
							<ul>
<li>'ready'</li>
<li>'not-ready'</li>
<li>'connecting'</li>
<li>'disconnecting'</li>
<li>'connected'</li>
</ul>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_31">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_31">&#182;</a>
							</div>
							<p><strong>Todo:</strong> Need to revise all states.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			getState: function () {
				return getSignalingState.call(this);
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_32">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_32">&#182;</a>
							</div>
							<p><strong>[Public API]:</strong> It is public method of <code>connection</code> object. Returns <code>xRtc.Stream[]</code> object where each stream is <code>stream</code> which was added by <code>addStream</code> public method. For the most cases this <code>array</code> will be contain only one stream.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			getLocalStreams: function () {
</code></pre>
						</td>
					</tr>
					<tr id="section_33">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_33">&#182;</a>
							</div>
							<p>Return the copy of internal array.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>				return localStreams.map(function (stream) {
					return stream;
				});
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_34">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_34">&#182;</a>
							</div>
							<p><strong>[Public API]:</strong> It is public method of <code>connection</code> object. Returns <code>xRtc.Stream[]</code> object where each stream is <code>stream</code> which tranferred from the remote side.
<strong>Note:</strong> Each remote <code>xRtc.Stream</code> creates asynchronously on <code>remotestreamadded</code> (xrtc.Room.events.remoteStreamAdded) event and will be accessible in this array after mentioned event only.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			getRemoteStreams: function () {
</code></pre>
						</td>
					</tr>
					<tr id="section_35">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_35">&#182;</a>
							</div>
							<p>Return the copy of internal array.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>				return remoteStreams.map(function (stream) {
					return stream;
				});
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_36">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_36">&#182;</a>
							</div>
							<p><strong>[Public API]:</strong> It is public method of <code>connection</code> object. Returns <code>xRtc.DataChannel[]</code> object where each channel is <code>channel</code>which was created using <code>createDataChannel</code> public method.
<strong>Note:</strong> Each <code>xRtc.DataChannel</code> creates asynchronously on <code>datachannelcreated</code> (<code>xrtc.Room.events.dataChannelCreated</code>) event and will be accessible in this array after mentioned event only.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			getDataChannels: function () {
</code></pre>
						</td>
					</tr>
					<tr id="section_37">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_37">&#182;</a>
							</div>
							<p>Return the copy of internal array.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>				return dataChannels.map(function (channel) {
					return channel;
				});
			},
		});

</code></pre>
						</td>
					</tr>
					<tr id="section_38">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_38">&#182;</a>
							</div>
							<p>Internal helper method which throws appropriate exception in case when someone try to call <code>addStream</code> or <code>createDataChannel</code> methods at inappropriate time.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>		function throwExceptionOfWrongmethodCall(methodName) {
			var error = new xrtc.CommonError(methodName, &quot;The method can be called on &#39;&quot; +
				xrtc.Room.events.connectionCreated +
				&quot;&#39; event of the xRtc.Room. Use xRtc.Room.events.connectionCreated for access the event name.&quot;);
			logger.error(methodName, error);
		}

</code></pre>
						</td>
					</tr>
					<tr id="section_39">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_39">&#182;</a>
							</div>
							<p>Internal method which helps to subscribe to all events of <code>handshakeController</code> object where <code>handshakeController</code> is internal object and bridge between <code>xRtc.Connection</code> and <code>xRtc.Room</code>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>		function subscribeToHandshakeControllerEvents() {
			var hcEvents = xrtc.HandshakeController.events;
			handshakeController
				.on(hcEvents.receiveIce, proxy(onReceiveIce))
				.on(hcEvents.receiveOffer, proxy(onReceiveOffer))
				.on(hcEvents.receiveAnswer, proxy(onReceiveAnswer))
				.on(hcEvents.receiveBye, proxy(onReceiveBye));
		}

</code></pre>
						</td>
					</tr>
					<tr id="section_40">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_40">&#182;</a>
							</div>
							<p>Internal method which used for initialization of internal <code>peerConnection</code>. During execution of this method following async request will be performed:</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_41">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_41">&#182;</a>
							</div>
							<ul>
<li>Async ajax request to sever side for the <code>Token</code>.</li>
<li>Async ajax request to the sever side for the ice severs collection.</li>
</ul>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>		function initPeerConnection(userId, callback) {
			remoteUserId = userId;

			if (!peerConnection) {
				getIceServers.call(this, proxy(onIceServersGot));
			} else {
				callCallback();
			}

</code></pre>
						</td>
					</tr>
					<tr id="section_42">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_42">&#182;</a>
							</div>
							<p><strong>Todo:</strong> Need to think of this approach and refactor it.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			function callCallback() {
				if (typeof callback === &quot;function&quot;) {
					try {
						callback();
					} catch (e) {
</code></pre>
						</td>
					</tr>
					<tr id="section_43">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_43">&#182;</a>
							</div>
							<p><strong>Todo:</strong> Check or not check?</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>					}
				}
			}

</code></pre>
						</td>
					</tr>
					<tr id="section_44">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_44">&#182;</a>
							</div>
							<p>Internal helper method which used for creation browser compatible ice servers. ice server format depens on browser and browser version.
<em>Chrome 24-27</em> uses follwing format (example):</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_45">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_45">&#182;</a>
							</div>
							<p><code>[{"url":"stun:stun.l.google.com:19302"}, {url:"turn: userName@domain.com:3478",credential:"password"}]</code></p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_46">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_46">&#182;</a>
							</div>
							<p><em>FireFox 23+</em> (in context of TURN server) and <em>Chrome 28+</em> uses following format (example):</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_47">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_47">&#182;</a>
							</div>
							<p><code>[{"url":"stun:stun.l.google.com:19302"}, {"username":"user name","url":"turn:turn.domain.com","credential":"user password"}]</code></p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			function createBrowserCompatibleIceServers(iceServersArray) {
				var browserCompatibleIceServers = [];
</code></pre>
						</td>
					</tr>
					<tr id="section_48">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_48">&#182;</a>
							</div>
							<p><strong>Note:</strong> The code regarding creation ice servers in appropriate format was copied from <a href="https://apprtc.appspot.com/js/adapter.js">https://apprtc.appspot.com/js/adapter.js</a> (official demo of the Google).</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_49">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_49">&#182;</a>
							</div>
							<p><strong>Note:</strong> <em>FF</em> &lt; 23 (maybe &lt; 24, need to check it) can't resolve IP by URL. As a result IP addresses should be used for ice servers. <em>FF</em> 24 doesn't have this problem. Checked.
Creates iceServer from the url for <em>FF</em>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>				var createFireFoxTurnServer = function (url, username, password) {
					var iceServer = null;
					var url_parts = url.split(&#39;:&#39;);
					if (url_parts[0].indexOf(&#39;stun&#39;) === 0) {
</code></pre>
						</td>
					</tr>
					<tr id="section_50">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_50">&#182;</a>
							</div>
							<p>Create iceServer with stun url.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>						iceServer = { &#39;url&#39;: removeRedundantSymbolFromTheEnd(url, &quot;/&quot;) };
					} else if (url_parts[0].indexOf(&#39;turn&#39;) === 0 &amp;&amp;
							   (url.indexOf(&#39;transport=udp&#39;) !== -1 ||
								url.indexOf(&#39;?transport&#39;) === -1)) {
</code></pre>
						</td>
					</tr>
					<tr id="section_51">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_51">&#182;</a>
							</div>
							<p>Create iceServer with turn url.
Ignore the transport parameter from TURN url.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>						var turn_url_parts = url.split(&quot;?&quot;);
						iceServer = {
							&#39;url&#39;: removeRedundantSymbolFromTheEnd(turn_url_parts[0], &quot;/&quot;),
							&#39;credential&#39;: password,
							&#39;username&#39;: username
						};
					}
					return iceServer;
				};

</code></pre>
						</td>
					</tr>
					<tr id="section_52">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_52">&#182;</a>
							</div>
							<p>Creates iceServer from the url for Chrome.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>				var createCromeTurnServer = function (url, username, password) {
					var iceServer = null;
					var url_parts = url.split(&#39;:&#39;);
					if (url_parts[0].indexOf(&#39;stun&#39;) === 0) {
</code></pre>
						</td>
					</tr>
					<tr id="section_53">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_53">&#182;</a>
							</div>
							<p>Create iceServer with stun url.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>						iceServer = { &#39;url&#39;: removeRedundantSymbolFromTheEnd(url, &quot;/&quot;) };
					} else if (url_parts[0].indexOf(&#39;turn&#39;) === 0) {
						if (webrtc.detectedBrowserVersion &lt; 28) {
</code></pre>
						</td>
					</tr>
					<tr id="section_54">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_54">&#182;</a>
							</div>
							<p>For <em>pre-M28 Chrome</em> versions use old TURN format.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>							var url_turn_parts = url.split(&quot;turn:&quot;);
							iceServer = {
								&#39;url&#39;: &#39;turn:&#39; + username + &#39;@&#39; + url_turn_parts[1],
								&#39;credential&#39;: password
							};
						} else {
</code></pre>
						</td>
					</tr>
					<tr id="section_55">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_55">&#182;</a>
							</div>
							<p>For <em>Chrome M28</em> &amp; above use new TURN format.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>							iceServer = {
								&#39;url&#39;: removeRedundantSymbolFromTheEnd(url, &quot;/&quot;),
								&#39;credential&#39;: password,
								&#39;username&#39;: username
							};
						}
					}
					return iceServer;
				};

				function removeRedundantSymbolFromTheEnd(str, symbol) {
					var result = str;
					if (str[str.length - 1] === symbol) {
						result = str.substring(0, str.length - 1);
					}

					return result;
				}

				var createBrowserCompatibleServer = function (iceServerData) {
					var resultIceServer;
					if (webrtc.detectedBrowser == webrtc.supportedBrowsers.chrome) {
						resultIceServer = createCromeTurnServer(iceServerData.url, iceServerData.username, iceServerData.credential);
					} else {
						resultIceServer = createFireFoxTurnServer(iceServerData.url, iceServerData.username, iceServerData.credential);
					}

					return resultIceServer;
				};

				for (var i = 0, l = iceServersArray.length; i &lt; l; i++) {
					var browserCompatibleServer = createBrowserCompatibleServer(iceServersArray[i]);
					if (browserCompatibleServer) {
						browserCompatibleIceServers.push(browserCompatibleServer);
					}
				}

				return browserCompatibleIceServers;
			}

			function onIceServersGot(iceServersArray) {
				var self = this;

				var browserCompatibleIceServers = createBrowserCompatibleIceServers(iceServersArray);

				peerConnection = new webrtc.RTCPeerConnection(
					browserCompatibleIceServers &amp;&amp; browserCompatibleIceServers.length &gt; 0 ? { iceServers: browserCompatibleIceServers } : null,
					xrtc.Connection.settings.peerConnectionOptions);
				logger.info(&#39;initPeerConnection&#39;, &#39;PeerConnection created.&#39;);

</code></pre>
						</td>
					</tr>
					<tr id="section_56">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_56">&#182;</a>
							</div>
							<p><strong>Note:</strong> <em>Firefox (FF 24 at least)</em> does not currently generate 'trickle candidates'. This means that it will include its
candidate addresses as 'c' lines in the <code>offer</code>/<code>answer</code>, and the onicecandidate callback will never be called.
The downside to this approach is that Firefox must wait for all of its candidates to be gathered before creating its <code>offer</code>/<code>answer</code>
(a process which can involve contacting STUN and TURN servers and waiting for either the responses or for the requests timeout).
<a href="http://stackoverflow.com/questions/15484729/why-doesnt-onicecandidate-work">http://stackoverflow.com/questions/15484729/why-doesnt-onicecandidate-work</a>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>				peerConnection.onicecandidate = proxy(onIceCandidate);

				peerConnection.onstatechange = // M25-M26
</code></pre>
						</td>
					</tr>
					<tr id="section_57">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_57">&#182;</a>
							</div>
							<p><em>FF</em> 20.0.1 (<em>FF</em> 21+ works fine): during assigning <code>peerConnection.onsignalingstatechange</code> field <em>FF</em> throw following error:
NS<em>ERROR</em>XPC<em>CANT</em>MODIFY<em>PROP</em>ON_WN: Cannot modify properties of a WrappedNative</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>					peerConnection.onsignalingstatechange = // M27+, FF24+
					proxy(onConnectionStateChange);

</code></pre>
						</td>
					</tr>
					<tr id="section_58">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_58">&#182;</a>
							</div>
							<p>In <em>FireFox</em> &lt; 24 onstatechange or alternative event does not fire properly.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>				if (webrtc.detectedBrowser === webrtc.supportedBrowsers.firefox &amp;&amp; webrtc.detectedBrowserVersion &lt; 24) {
					var connectionState = this.getState();
					checkConnectionStateIntervalId = exports.setInterval(function () {
						var currentConnectionState = self.getState();
						if (currentConnectionState != connectionState) {
							logger.debug(&#39;setInterval -&gt; xrtc.Connection.events.stateChanged&#39;, currentConnectionState);
							connectionState = currentConnectionState;
							self.trigger(xrtc.Connection.events.stateChanged, connectionState);
						}
					}, 500);
				}

</code></pre>
						</td>
					</tr>
					<tr id="section_59">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_59">&#182;</a>
							</div>
							<p><strong>Todo:</strong> Need to think about the necessity of this handlers.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>				peerConnection.onicechange = // M25-M26
</code></pre>
						</td>
					</tr>
					<tr id="section_60">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_60">&#182;</a>
							</div>
							<p><em>FF 20.0.1</em> (FF 21+ works fine): during assigning peerConnection.oniceconnectionstatechange field <em>FF</em> throw following error: NS<em>ERROR</em>XPC<em>CANT</em>MODIFY<em>PROP</em>ON_WN: Cannot modify properties of a WrappedNative</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>					peerConnection.oniceconnectionstatechange = // M27+, FF24+
					proxy(onIceStateChange);

				peerConnection.ondatachannel = function (channelData) {
					var newDataChannel = new xrtc.DataChannel(channelData.channel, remoteUserId);
					dataChannels.push(newDataChannel);
					self.trigger(xrtc.Connection.events.dataChannelCreated, { channel: newDataChannel });
				};

</code></pre>
						</td>
					</tr>
					<tr id="section_61">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_61">&#182;</a>
							</div>
							<p><em>FF 19-20.0.1</em> (maybe earlier, <em>FF21</em> works fine): fire this event twice, for video stream and for audio stream despite the fact that one stream was added by remote side.
It is called any time a MediaStream is added by the remote peer. This will be fired only as a result of <code>setRemoteDescription</code>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>				peerConnection.onaddstream = proxy(onAddStream);

</code></pre>
						</td>
					</tr>
					<tr id="section_62">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_62">&#182;</a>
							</div>
							<p>For <em>FF</em> only (Tested for <em>FF24</em>. Magic, sometimes works and sometimes not.)</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>				peerConnection.onclosedconnection = function (closeData/*temporary ignores*/) {
					logger.debug(&#39;peerConnection.onclosedconnection&#39;, closeData);
					closePeerConnection.call(self);
				};

</code></pre>
						</td>
					</tr>
					<tr id="section_63">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_63">&#182;</a>
							</div>
							<p><strong>Todo:</strong> Need to fire close connection event for <em>Chrome M26</em>. The logic should be based on <code>peerConnection.iceConnectionState</code> field and <code>window.setInterval</code>.
<strong>Todo:</strong> Need to fire close connection event for <em>Chrome M25</em>. The logic should be based on <code>peerConnection.iceState</code> field and <code>window.setInterval</code>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_64">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_64">&#182;</a>
							</div>
							<p>peerConnection.iceGatheringState
W3C Editor's Draft 30 August 2013:
enum RTCIceGatheringState {
    "new",
    "gathering",
    "complete"
};</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
				function onIceCandidate(evt) {
					if (!!evt.candidate) {
</code></pre>
						</td>
					</tr>
					<tr id="section_65">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_65">&#182;</a>
							</div>
							<p>In the original <code>RTCIceCandidate</code> class <code>candidate</code> property is immutable.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>						var ice = JSON.parse(JSON.stringify(evt.candidate));

						if (iceFilter.isAllowed(ice)) {
							handleIceCandidate.call(this, ice);
						}
					}
				}

				function onConnectionStateChange(evt) {
					logger.debug(&#39;onConnectionStateChange&#39;, evt);
					this.trigger(xrtc.Connection.events.stateChanged, this.getState());
				}

				function onIceStateChange(evt) {
					var state = getIceState.call(self);

					logger.debug(&quot;onIceStateChange&quot;, new Date().getTime(), state);
					if (checkDisconnectedIceStateTimeoutId) {

						logger.debug(&quot;onIceStateChange&quot;, new Date().getTime(),
							&quot;checkDisconnectedIceStateTimeout are clearing. ID = &#39;&quot; + checkDisconnectedIceStateTimeoutId + &quot;&#39;&quot;);

						exports.clearTimeout(checkDisconnectedIceStateTimeoutId);
						checkDisconnectedIceStateTimeoutId = null;

						logger.debug(&quot;onIceStateChange&quot;, new Date().getTime(),
							&quot;checkDisconnectedIceStateTimeout was cleared. ID = &#39;&quot; + checkDisconnectedIceStateTimeoutId + &quot;&#39;&quot;);
					}

					if (state === &#39;connected&#39;) {
</code></pre>
						</td>
					</tr>
					<tr id="section_66">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_66">&#182;</a>
							</div>
							<p><strong>Todo:</strong> Need to think about name of this event.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>						self.trigger(xrtc.Connection.events.connectionEstablished, { userId: remoteUserId });
					} else if (state === &#39;disconnected&#39;) {
						var closeDisconnectedConnectionTimeout = 10000;

						logger.debug(&quot;onIceStateChange&quot;, new Date().getTime(),
							&quot;checkDisconnectedIceStateTimeout(&quot; + closeDisconnectedConnectionTimeout / 1000 + &quot;sec.) was started.&quot;);

						checkDisconnectedIceStateTimeoutId = exports.setTimeout(function () {

							logger.debug(&quot;onIceStateChange&quot;, new Date().getTime(),
								&quot;ice state equals &#39;disconnected&#39; so closePeerConnection was called. Timeout is &quot; +
									closeDisconnectedConnectionTimeout / 1000 + &quot;sec and it is expired.&quot;);

</code></pre>
						</td>
					</tr>
					<tr id="section_67">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_67">&#182;</a>
							</div>
							<p><strong>Todo:</strong> The event should't be repeated for <em>FF 24+</em>, because <em>FF 18+</em> has peerConnection.onclosedconnection and <em>FF 24+</em> has peerConnection.oniceconnectionstatechange.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>							closePeerConnection.call(self);
							exports.clearInterval(checkDisconnectedIceStateTimeoutId);
							checkDisconnectedIceStateTimeoutId = null;
						}, closeDisconnectedConnectionTimeout);

						logger.debug(&quot;onIceStateChange&quot;, new Date().getTime(),
							&quot;checkDisconnectedIceStateTimeout ID =&#39;&quot; + checkDisconnectedIceStateTimeoutId + &quot;&#39;&quot;);
					}
				}

				function onAddStream(evt) {
					addRemoteStream.call(this, evt.stream);
				}

</code></pre>
						</td>
					</tr>
					<tr id="section_68">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_68">&#182;</a>
							</div>
							<p>Add streams to native webrtc peerConnection which were added before.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>				for (var i = 0, len = localStreams.length; i &lt; len; i++) {
					peerConnection.addStream(localStreams[i].getStream());
				}

</code></pre>
						</td>
					</tr>
					<tr id="section_69">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_69">&#182;</a>
							</div>
							<p>Create data channnels which were created(registered for creation) before.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>				for (var i = 0, len = dataChannelNames.length; i &lt; len; i++) {
					createDataChannel.call(this, dataChannelNames[i]);
				}

				callCallback();
			}
		}

</code></pre>
						</td>
					</tr>
					<tr id="section_70">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_70">&#182;</a>
							</div>
							<p>Internal helper method which creates new instance of DataChannel by channel name.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>		function createDataChannel(name) {
			var self = this;
			try {
</code></pre>
						</td>
					</tr>
					<tr id="section_71">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_71">&#182;</a>
							</div>
							<p><em>FF 19-21(and 18 maybe)</em>: Data channels should be created after connection establishment.
Connection should be established usually with audio and/or video.  For the time being,
always at least include a 'fake' audio stream - this will be fixed soon.
After connection establishment need to call <code>pc.connectDataConnection(5001, 5000);</code> on th each side.
For the two sides need to use inverted copies of the two numbers (e.g. <code>5000</code>, <code>5001</code> on one side, <code>5001</code>, <code>5000</code> on the other).
connectDataConnection is a temporary function that will soon disappear.
For more information see <a href="https://hacks.mozilla.org/2012/11/progress-update-on-webrtc-for-firefox-on-desktop/">https://hacks.mozilla.org/2012/11/progress-update-on-webrtc-for-firefox-on-desktop/</a></p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_72">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_72">&#182;</a>
							</div>
							<p>As a result current library approach of data channels creation works only for <em>FF 22+</em>.
for earlier versions exception will be thrown: Component returned failure code:
0x80004005 (NS<em>ERROR</em>FAILURE) [IPeerConnection.createDataChannel]" nsresult: "0x80004005 (NS<em>ERROR</em>FAILURE)"</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_73">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_73">&#182;</a>
							</div>
							<p>Reliable channel is analogous to a TCP socket and unreliable channel is analogous to a UDP socket.
Reliable data channels currently supports only by <em>FF</em>. It is default value.
In <em>Chrome</em> reliable channels doesn't implemented yet: <a href="https://code.google.com/p/webrtc/issues/detail?id=1430">https://code.google.com/p/webrtc/issues/detail?id=1430</a></p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>				var dc = peerConnection.createDataChannel(name, webrtc.detectedBrowser === webrtc.supportedBrowsers.chrome ? { reliable: false } : {});
</code></pre>
						</td>
					</tr>
					<tr id="section_74">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_74">&#182;</a>
							</div>
							<p><strong>Todo:</strong> Need to check, maybe <code>peerConnection.ondatachannel</code> fires not only for offer receiver but and for offer sender user. If so then firing of this event should be removed here.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>				var newDataChannel = new xrtc.DataChannel(dc, remoteUserId);
				dataChannels.push(newDataChannel);
				self.trigger(xrtc.Connection.events.dataChannelCreated, { channel: newDataChannel });
			} catch (ex) {
				var error = new xrtc.CommonError(&#39;createDataChannel&#39;, &quot;Can&#39;t create DataChannel.&quot;, ex);
				logger.error(&#39;createDataChannel&#39;, error);
				self.trigger(xrtc.Connection.events.dataChannelCreationError, { channelName: name, error: error });
			}
		}

		function handleIceCandidate(ice) {
			iceCandidates.push(ice);

			if (connectionEstablished) {
				sendIceCandidates.call(this);
			}
		}

		function allowIceSending() {
			connectionEstablished = true;

</code></pre>
						</td>
					</tr>
					<tr id="section_75">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_75">&#182;</a>
							</div>
							<p>Send already generated ice candidates.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			sendIceCandidates.call(this);
		}

		function sendIceCandidates() {
			for (var i = 0; i &lt; iceCandidates.length; i++) {
				var iceCandidate = iceCandidates[i];

				handshakeController.sendIce(remoteUserId, remoteConnectionId, connectionId, JSON.stringify(iceCandidate));
				this.trigger(xrtc.Connection.events.iceSent, { iceCandidate: iceCandidate });
			}

			iceCandidates = [];
		}

		function addRemoteStream(stream) {
			var newXrtcStream = new xrtc.Stream(stream);
			remoteStreams.push(newXrtcStream);

			var streamData = {
				stream: newXrtcStream,
				userId: remoteUserId
			};

			logger.debug(&#39;addRemoteStream&#39;, streamData);

			this.trigger(xrtc.Connection.events.remoteStreamAdded, streamData);
		}

		function getIceServers(callback) {
			if (typeof callback === &quot;function&quot;) {
				if (iceServers) {
					callback(iceServers);
				} else {
					authManager.getToken(userData, function (token) {
						authManager.getIceServers(token, userData, function (servers) {
							iceServers = servers;
							callback(iceServers);
						});
					});
				}
			}
		}

		function onReceiveIce(iceData) {
			logger.debug(&#39;Ice candidate was received.&#39;, iceData);
			var iceCandidate = new webrtc.RTCIceCandidate(JSON.parse(iceData.iceCandidate));
			peerConnection.addIceCandidate(iceCandidate);

			this.trigger(xrtc.Connection.events.iceAdded, { iceCandidate: iceCandidate });
		}

		function onReceiveOffer(offerData) {
			logger.debug(&#39;Offer was received.&#39;, offerData);

			iceServers = offerData.iceServers;
			remoteConnectionId = offerData.connectionId;

			initPeerConnection.call(this, remoteUserId, function () {
				logger.debug(&#39;receiveOffer&#39;, offerData);
				iceFilter = new internal.IceCandidateFilter(offerData.connectionType, iceServers);

				var sdp = JSON.parse(offerData.offer);

				var remoteSessionDescription = new webrtc.RTCSessionDescription(sdp);
				peerConnection.setRemoteDescription(remoteSessionDescription);

				peerConnection.createAnswer(proxy(onCreateAnswerSuccess), proxy(onCreateAnswerError), xrtc.Connection.settings.answerOptions);

				function onCreateAnswerSuccess(answer) {
					if (webrtc.detectedBrowser === webrtc.supportedBrowsers.firefox) {
						answer.sdp = iceFilter.filterSDP(answer.sdp);
					}

					peerConnection.setLocalDescription(answer);

					var request = {
						answer: JSON.stringify(answer)
					};

					logger.debug(&#39;sendAnswer&#39;, offerData, answer);
					handshakeController.sendAnswer(remoteUserId, remoteConnectionId, connectionId, request);

					this.trigger(xrtc.Connection.events.answerSent, { userId: remoteUserId, answerData: request });

					allowIceSending.call(this);
				}

				function onCreateAnswerError(err) {
					var error = new xrtc.CommonError(&#39;sendAnswer&#39;, &quot;Cannot create WebRTC answer&quot;, err);

					logger.error(&#39;sendAnswer&#39;, error);
					this.trigger(xrtc.Connection.events.createAnswerError, error);
				}
			});
		}

		function onReceiveAnswer(answerData) {
			logger.debug(&#39;Answer was received.&#39;, answerData);

			remoteConnectionId = answerData.connectionId;

			allowIceSending.call(this);

			var sdp = JSON.parse(answerData.answer);
			var sessionDescription = new webrtc.RTCSessionDescription(sdp);
			peerConnection.setRemoteDescription(sessionDescription);
			this.trigger(xrtc.Connection.events.answerReceived, { userId: remoteConnectionId, answerData: { answer: sessionDescription } });
		}

		function onReceiveBye() {
			closePeerConnection.call(this);
		}

		function closePeerConnection() {
			var self = this;

			if (webrtc.detectedBrowser === webrtc.supportedBrowsers.firefox &amp;&amp; checkConnectionStateIntervalId) {
				exports.clearInterval(checkConnectionStateIntervalId);
				checkConnectionStateIntervalId = null;
			}

			if (peerConnection) {
				peerConnection.onicecandidate = null;
				peerConnection.close();
				peerConnection = null;
				iceCandidates = [];
				iceServers = null;
				connectionEstablished = false;
				connectionIsOpened = false;

				var closeConnectionData = {
					sender: self,
					userId: remoteUserId
				};

				remoteUserId = null;

				this.trigger(xrtc.Connection.events.connectionClosed, closeConnectionData);
			}
		}

		function getIceState() {
			/* W3C Editor&#39;s Draft 30 August 2013:
			enum RTCIceConnectionState {
				&quot;new&quot;,
				&quot;checking&quot;,
				&quot;connected&quot;,
				&quot;completed&quot;,
				&quot;failed&quot;,
				&quot;disconnected&quot;,
				&quot;closed&quot;
			};
			*/

			var state = peerConnection
							&amp;&amp; (peerConnection.iceConnectionState // M26+
							|| peerConnection.iceState) // M25
						|| &#39;notinitialized&#39;;

			return state;
		}

</code></pre>
						</td>
					</tr>
					<tr id="section_76">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_76">&#182;</a>
							</div>
							<p><strong>Todo:</strong> Need to think about available states.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>		function getSignalingState() {
			/* W3C Editor&#39;s Draft 30 August 2013:
			enum RTCSignalingState {
				&quot;stable&quot;,
				&quot;have-local-offer&quot;,
				&quot;have-remote-offer&quot;,
				&quot;have-local-pranswer&quot;,
				&quot;have-remote-pranswer&quot;,
				&quot;closed&quot;
			};
			*/

</code></pre>
						</td>
					</tr>
					<tr id="section_77">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_77">&#182;</a>
							</div>
							<p><strong>Warning:</strong> It can change from version to version.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			var isLocalStreamAdded = localStreams.length &gt; 0,
				states = {
</code></pre>
						</td>
					</tr>
					<tr id="section_78">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_78">&#182;</a>
							</div>
							<p><strong>Todo:</strong> Why not-ready if local stream is not added? What about situation when only text chat will be used?</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>					&#39;notinitialized&#39;: isLocalStreamAdded ? &#39;ready&#39; : &#39;not-ready&#39;,

</code></pre>
						</td>
					</tr>
					<tr id="section_79">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_79">&#182;</a>
							</div>
							<p><em>Chrome M25</em>.
<strong>Todo:</strong> Why not-ready if local stream is not added? What about situation when only text chat will be used?</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>					&#39;new&#39;: isLocalStreamAdded ? &#39;ready&#39; : &#39;not-ready&#39;,
					&#39;opening&#39;: &#39;connecting&#39;,
					&#39;active&#39;: &#39;connected&#39;,
					&#39;closing&#39;: &#39;disconnecting&#39;,
</code></pre>
						</td>
					</tr>
					<tr id="section_80">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_80">&#182;</a>
							</div>
							<p><strong>Todo:</strong> Why not-ready if local stream is not added? What about situation when only text chat will be used?</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>					&#39;closed&#39;: isLocalStreamAdded ? &#39;ready&#39; : &#39;not-ready&#39;,

</code></pre>
						</td>
					</tr>
					<tr id="section_81">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_81">&#182;</a>
							</div>
							<p><em>Chrome M26+</em>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>					&#39;stable&#39;: &#39;connected&#39;,
					&#39;have-local-offer&#39;: &#39;ready&#39;,
					&#39;have-remote-offer&#39;: &#39;connecting&#39;
				},
				state = peerConnection
						&amp;&amp; (peerConnection.signalingState // M26+
						|| peerConnection.readyState) // M25-M26
					|| &#39;notinitialized&#39;;

			return states[state];
		}

</code></pre>
						</td>
					</tr>
					<tr id="section_82">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_82">&#182;</a>
							</div>
							<p><em>Todo:</em> Need to move this method to <code>xrtc.utils</code>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>		function generateGuid() {
			var guid = &#39;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&#39;.replace(/[xy]/g, function (c) {
				var r = Math.random() * 16 | 0, v = c == &#39;x&#39; ? r : (r &amp; 0x3 | 0x8);
				return v.toString(16);
			});
			return guid;
		};
	});

	xrtc.Connection.extend({
</code></pre>
						</td>
					</tr>
					<tr id="section_83">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_83">&#182;</a>
							</div>
							<p><strong>Note:</strong> Full list of events for the <code>xRtc.Connection</code> object.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>		events: {
			localStreamAdded: &#39;localstreamadded&#39;,
			remoteStreamAdded: &#39;remotestreamadded&#39;,

			iceAdded: &#39;iceadded&#39;,
			iceSent: &#39;icesent&#39;,

			offerSent: &#39;offersent&#39;,
			createOfferError: &#39;createoffererror&#39;,

			answerSent: &#39;answersent&#39;,
			answerReceived: &#39;answerreceived&#39;,
			createAnswerError: &#39;createanswererror&#39;,

			dataChannelCreated: &#39;datachannelcreated&#39;,
			dataChannelCreationError: &#39;datachannelcreationerror&#39;,

			connectionOpening: &#39;connectionopening&#39;,
			connectionEstablished: &#39;connectionestablished&#39;,
			connectionClosed: &#39;connectionclosed&#39;,

			stateChanged: &#39;statechanged&#39;
		},

</code></pre>
						</td>
					</tr>
					<tr id="section_84">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_84">&#182;</a>
							</div>
							<p>Following connection types are supported by <code>xRtc</code> library:</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>
</code></pre>
						</td>
					</tr>
					<tr id="section_85">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_85">&#182;</a>
							</div>
							<ul>
<li><code>default</code>. It is mean standart mechanism of connection establishment. At first trying to establish direct p2p connection without STUN or TURN usage. If previous point is not possible then trying to establish STUN connection. If previous point is not possible then establish TURN connection.</li>
<li><code>direct</code>. It is mean direct p2p or STUN connection establishment.</li>
<li><code>server</code>. It is mean only TURN connection establishment.</li>
</ul>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>		connectionTypes: {
			default: &#39;default&#39;,
			direct: &#39;direct&#39;,
			server: &#39;server&#39;
		},

		settings: {
			offerOptions: {
				optional: [],
				mandatory: {
					OfferToReceiveAudio: true,
					OfferToReceiveVideo: true
				}
			},

			answerOptions: {
				optional: [],
				mandatory: {
					OfferToReceiveAudio: true,
					OfferToReceiveVideo: true
				}
			},

</code></pre>
						</td>
					</tr>
					<tr id="section_86">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_86">&#182;</a>
							</div>
							<p>Interop Notes between <em>Chrome M25 and Firefox Nightly (version 21)</em>:
<em>Chrome</em> does not yet do DTLS-SRTP by default whereas <em>Firefox</em> only does DTLS-SRTP. In order to get interop,
you must supply Chrome with a PC constructor constraint to enable DTLS: <code>{ 'optional': [{'DtlsSrtpKeyAgreement': 'true'}]}</code></p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>			peerConnectionOptions: {
				optional: [{ RtpDataChannels: true }, { DtlsSrtpKeyAgreement: true }]
			}
		}
	});

</code></pre>
						</td>
					</tr>
					<tr id="section_87">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_87">&#182;</a>
							</div>
							<p>Cross-browser support: New syntax of <code>getXXXStreams</code> method in <em>Chrome M26</em>.
For <em>FireFox 22</em> <code>webrtc.RTCPeerConnection.prototype</code> is undefined.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>	if (webrtc.RTCPeerConnection.prototype &amp;&amp; !webrtc.RTCPeerConnection.prototype.getLocalStreams) {
		xrtc.Class.extend(webrtc.RTCPeerConnection.prototype, {
			getLocalStreams: function () {
				return this.localStreams;
			},

			getRemoteStreams: function () {
				return this.remoteStreams;
			}
		});
	}

</code></pre>
						</td>
					</tr>
					<tr id="section_88">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_88">&#182;</a>
							</div>
							<p>Cross-browser support: New syntax of <code>getXXXTracks</code> method in <em>Chrome M26</em>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>	if (!webrtc.MediaStream.prototype.getVideoTracks) {
		if (webrtc.detectedBrowser === webrtc.supportedBrowsers.firefox) {
			xrtc.Class.extend(webrtc.MediaStream.prototype, {
				getVideoTracks: function () {
					return [];
				},

				getAudioTracks: function () {
					return [];
				}
			});
		} else {
			xrtc.Class.extend(webrtc.MediaStream.prototype, {
				getVideoTracks: function () {
					return this.videoTracks;
				},

				getAudioTracks: function () {
					return this.audioTracks;
				}
			});
		}
	}

</code></pre>
						</td>
					</tr>
					<tr id="section_89">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_89">&#182;</a>
							</div>
							<p><strong>Todo:</strong> No need to disable data channels in case of communication between <em>FireFox</em> and <em>Firefox</em>. These flags are necessary in case of interoperability between <em>FireFox</em> and <em>Chrome</em> only.
Data channels does't supported in case of interoperability of <em>FireFox</em> and <em>Chrome</em>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>	/*if (webrtc.detectedBrowser === webrtc.supportedBrowsers.firefox) {
</code></pre>
						</td>
					</tr>
					<tr id="section_90">
						<td class="docs">
							<div class="pilwrap">
								<a class="pilcrow" href="#section_90">&#182;</a>
							</div>
							<p><em>Chrome M26b</em> and <em>Chrome Canary</em> with this settings fires an erron on the creation of offer/answer, but it is necessary for interoperablity between <em>FF</em> and <em>Chrome</em>.</p>

						</td>
						<td class="code">
							<pre><code class='prettyprint'>		xrtc.Connection.settings.offerOptions.mandatory.MozDontOfferDataChannel = true;
		xrtc.Connection.settings.answerOptions.mandatory.MozDontOfferDataChannel = true;
	}*/
})(window);
</code></pre>
						</td>
					</tr>
			</tbody>
		</table>
	</div>
</body>
</html>
